<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How I improved consistency and performance in a Go crawler with retry logics and network tuning | Maxgio's blog</title><meta name=keywords content="go,performance,consistency,optimization"><meta name=description content="Introduction wfind is a simple web crawler for files and folders in web pages hyerarchies. The goal is basically the same of GNU find for file systems. At the same time it&rsquo;s inspired by GNU wget, and it merges the find features applied to files and directories exposed as HTML web resources.
In this blog we&rsquo;ll go through the way I improved consistency in this crawler, by implementing retry logics and tuning network and transport in the HTTP client."><meta name=author content><link rel=canonical href=https://blog.maxgio.me/posts/improving-consistency-performance-go-crawler-retry-logics-http-client-tuning/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://blog.maxgio.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.maxgio.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.maxgio.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.maxgio.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.maxgio.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-7DN0LVS78Q','auto');ga('send','pageview');}</script><meta property="og:title" content="How I improved consistency and performance in a Go crawler with retry logics and network tuning"><meta property="og:description" content="Introduction wfind is a simple web crawler for files and folders in web pages hyerarchies. The goal is basically the same of GNU find for file systems. At the same time it&rsquo;s inspired by GNU wget, and it merges the find features applied to files and directories exposed as HTML web resources.
In this blog we&rsquo;ll go through the way I improved consistency in this crawler, by implementing retry logics and tuning network and transport in the HTTP client."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.maxgio.me/posts/improving-consistency-performance-go-crawler-retry-logics-http-client-tuning/"><meta property="og:image" content="https://blog.maxgio.me/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-04T10:20:00+02:00"><meta property="article:modified_time" content="2023-09-04T10:20:00+02:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.maxgio.me/papermod-cover.png"><meta name=twitter:title content="How I improved consistency and performance in a Go crawler with retry logics and network tuning"><meta name=twitter:description content="Introduction wfind is a simple web crawler for files and folders in web pages hyerarchies. The goal is basically the same of GNU find for file systems. At the same time it&rsquo;s inspired by GNU wget, and it merges the find features applied to files and directories exposed as HTML web resources.
In this blog we&rsquo;ll go through the way I improved consistency in this crawler, by implementing retry logics and tuning network and transport in the HTTP client."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.maxgio.me/posts/"},{"@type":"ListItem","position":2,"name":"How I improved consistency and performance in a Go crawler with retry logics and network tuning","item":"https://blog.maxgio.me/posts/improving-consistency-performance-go-crawler-retry-logics-http-client-tuning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How I improved consistency and performance in a Go crawler with retry logics and network tuning","name":"How I improved consistency and performance in a Go crawler with retry logics and network tuning","description":"Introduction wfind is a simple web crawler for files and folders in web pages hyerarchies. The goal is basically the same of GNU find for file systems. At the same time it\u0026rsquo;s inspired by GNU wget, and it merges the find features applied to files and directories exposed as HTML web resources.\nIn this blog we\u0026rsquo;ll go through the way I improved consistency in this crawler, by implementing retry logics and tuning network and transport in the HTTP client.","keywords":["go","performance","consistency","optimization"],"articleBody":"Introduction wfind is a simple web crawler for files and folders in web pages hyerarchies. The goal is basically the same of GNU find for file systems. At the same time it’s inspired by GNU wget, and it merges the find features applied to files and directories exposed as HTML web resources.\nIn this blog we’ll go through the way I improved consistency in this crawler, by implementing retry logics and tuning network and transport in the HTTP client.\nParallelism and concurrency As a crawler, wfind is vital to efficiently do its work scraping web pages in parallel routines.\nFor scraping web pages wfind leverages go-colly, that allows run its collector in asynchronous mode. That mode simply fetches HTTP objects inside dedicated goroutines.\nFrom the user perspective (i.e. wfind), the synchronization is as simple as invoking the Wait function before completing. The API is provided by the Colly collector and it wraps around the standard WaitGroup’s Wait(), from the Go standard library’s sync package, waiting for all the fetch goroutines to complete.\nAs the go-colly implementation does not provide cap on the parallelism, the implementation can lead to the common concurrency problems, racing for OS and runtime resources client-side, server-side, and physical medium-side.\nClient-side, the maxmimum allowed open connections could prevent the client to open and then establish new ones during the scraping. The server could limit resource usage and we cannot predict the strategies and logics followed server-side. Also, the connection mean in the physical layer is another point of failure; for example latency might cause the HTTP client to time out during go-colly’s Visit waiting for a response.\nAt the end of the day a retry logics was fundamental in order to improve the consistency in the crawling. Furthermore, verifying the consistency through end-to-end functional tests is required to guarantee the expected behaviour of the program.\nEnd-to-end tests As end-to-end functional tests treat the program as a black-box and ensures that provide the value as expected, interacting with the real actors in the expected scenarios, I wrote tests again real CentOS kernel.org mirrors, looking for repository metadata files, as an example use case of wfind.\nI used GinkGo as I like how it easily enables to design and implement the specifications of the program as you write tests.\nMoreover, regardless of whether or not you follow BDD, tests tend to appear self-explanatory.\nIndeed, Ginkgo with Gomega matchers provide a DSL for writing tests in general like integration tests but also white-box and black-box unit tests.\npackage find_test import ( . \"github.com/onsi/ginkgo/v2\" . \"github.com/onsi/gomega\" \"github.com/maxgio92/wfind/internal/network\" \"github.com/maxgio92/wfind/pkg/find\" ) const ( seedURL = \"https://mirrors.edge.kernel.org/centos/8-stream\" fileRegexp = \"repomd.xml$\" expectedResults = 155 ) var _ = Describe(\"File crawling\", func() { Context(\"Async\", func() { var ( search = find.NewFind( find.WithAsync(true), find.WithSeedURLs([]string{seedURL}), find.WithFilenameRegexp(fileRegexp), find.WithFileType(find.FileTypeReg), find.WithRecursive(true), ) actual *find.Result err error expectedCount = expectedResults ) BeforeEach(func() { actual, err = search.Find() }) It(\"Should not fail\", func() { Expect(err).To(BeNil()) }) It(\"Should stage results\", func() { Expect(actual.URLs).ToNot(BeEmpty()) Expect(actual.URLs).ToNot(BeNil()) }) It(\"Should stage exact result count\", func() { Expect(len(actual.URLs)).To(Equal(expectedCount)) }) }) }) As you can see, the order in which results are returned is not important and thus not tested.\nRetry logics The first concrete goal of the retry logics was to start to see green flags from the GinkGo output.\nSo I expected to start by seeing tests to fail:\n$ ginkgo --focus \"File crawling\" pkg/find ... FAIL! ... Then, in order to make tests to pass, it was needed a way to ensure that requests failed would have been retried.\nFortunately go-colly provide way to register a callback, that as per the documentation it registers a function that will be executed if an error occurs during the HTTP request, with OnError.\nThat way it’s possible to run a custom handler as the response (and the request) object and the error are available in context of the helper, as for the signature.\nDumb retrier The first implementation of the retry could have been as simple as retry for a fixed amount of times, after a fixed amount of period.\nFor example:\ncollector.OnError(func(resp *colly.Response, err error) { time.Sleep(2 * time.Second) resp.Request.Retry() }) For sure this wasn’t enough to improve the probability to make failing requests to succeed.\nRetry with exponential backoff At first, a single retry might not be enough, and also, the optimal backoff size should vary depending on the failure cause and the context. Furthermore, it would be good to be increased as time passes in order to avoid overload on the actors.\nSo I decided to leverage the community projects and digging around backoff implementations. After that, I picked and imported github.com/cenkalti/backoff package. I liked the design as it respects all the SOLID principles and because it provides API to a tunable exponential backoff algorithm. Also, it allows to mix and match with different custom backoff algorithms, without needing to implement a ticker.\nFurthermore, I wanted to provide knobs to enable the retry behaviour for specific errors encountered doing HTTP requests. So I ended up including new dedicated options to the wfind/pkg/find’s ones:\npackage find // ...  // Options represents the options for the Find job. type Options struct { // ...  // ConnResetRetryBackOff controls the error handling on responses. \t// If not nil, when the connection is reset by the peer (TCP RST), the request \t// is retried with an exponential backoff interval. \tConnResetRetryBackOff *ExponentialBackOffOptions // TimeoutRetryBackOff controls the error handling on responses. \t// If not nil, when the connection times out (based on client timeout), the request \t// is retried with an exponential backoff interval. \tTimeoutRetryBackOff *ExponentialBackOffOptions // ContextDeadlineExceededRetryBackOff controls the error handling on responses. \t// If not nil, when the request context deadline exceeds, the request \t// is retried with an exponential backoff interval. \tContextDeadlineExceededRetryBackOff *ExponentialBackOffOptions } // ...  // crawlFiles returns a list of file names found from the seed URL, // filtered by file name regex. func (o *Options) crawlFiles() (*Result, error) { // Create the collector. \tco := colly.NewCollector(coOptions...) // Add the callback to Visit the linked resource, for each HTML element found \tco.OnHTML(HTMLTagLink, func(e *colly.HTMLElement) { // ... \t}) // Manage errors. \tco.OnError(o.handleError) // ...  // Wait until colly goroutines are finished. \tco.Wait() return \u0026Result{BaseNames: files, URLs: urls}, nil } // handleError handles an error received making a colly.Request. // It accepts a colly.Response and the error. func (o *Options) handleError(response *colly.Response, err error) { switch { // Context timed out. \tcase errors.Is(err, context.DeadlineExceeded): if o.ContextDeadlineExceededRetryBackOff != nil { retryWithExponentialBackoff(response.Request.Retry, o.TimeoutRetryBackOff) } // Request has timed out. \tcase os.IsTimeout(err): if o.TimeoutRetryBackOff != nil { retryWithExponentialBackoff(response.Request.Retry, o.TimeoutRetryBackOff) } // Connection has been reset (RST) by the peer. \tcase errors.Is(err, unix.ECONNRESET): if o.ConnResetRetryBackOff != nil { retryWithExponentialBackoff(response.Request.Retry, o.ConnResetRetryBackOff) } // Other failures. \tdefault: // ... \t} } With the implementation of the retry leveraging the cenkalti/backoff package, following the example provided:\n// retryWithExtponentialBackoff retries with an exponential backoff a function. // Exponential backoff can be tuned with options accepted as arguments to the function. func retryWithExponentialBackoff(retryF func() error, opts *ExponentialBackOffOptions) { ticker := backoff.NewTicker( utils.NewExponentialBackOff( utils.WithClock(opts.Clock), utils.WithInitialInterval(opts.InitialInterval), utils.WithMaxInterval(opts.MaxInterval), utils.WithMaxElapsedTime(opts.MaxElapsedTime), ), ) var err error // Ticks will continue to arrive when the previous retryF is still running, \t// so operations that take a while to fail could run in quick succession. \tfor range ticker.C { if err = retryF(); err != nil { // Retry. \tcontinue } ticker.Stop() break } if err != nil { // Retry has failed. \treturn } // Retry is successful. } And the end-to-end test could have been updated by enabling the retry behaviour for the context deadline exceeded, HTTP client transport’s timeout, connection reset by peer cases:\nvar _ = Describe(\"File crawling\", func() { Context(\"Async\", func() { var ( search = find.NewFind( find.WithAsync(true), find.WithSeedURLs([]string{seedURL}), find.WithClientTransport(network.DefaultClientTransport), find.WithFilenameRegexp(fileRegexp), find.WithFileType(find.FileTypeReg), find.WithRecursive(true), // Enable retry backoff with default parameters. \tfind.WithContextDeadlineExceededRetryBackOff(find.DefaultExponentialBackOffOptions), find.WithConnTimeoutRetryBackOff(find.DefaultExponentialBackOffOptions), find.WithConnResetRetryBackOff(find.DefaultExponentialBackOffOptions), ) actual *find.Result err error expectedCount = expectedResults ) BeforeEach(func() { actual, err = search.Find() }) It(\"Should not fail\", func() { Expect(err).To(BeNil()) }) It(\"Should stage results\", func() { Expect(actual.URLs).ToNot(BeEmpty()) Expect(actual.URLs).ToNot(BeNil()) }) It(\"Should stage exact result count\", func() { Expect(len(actual.URLs)).To(Equal(expectedCount)) }) }) }) And I re-run the e2e test again:\n$ ginkgo --focus \"File crawling\" pkg/find But the tests took too much time consuming a lot of memory until it was out-of-memory killed. Likely a memory leak or simply not efficient memory management was already present, but without retry logics nor performance tests it hadn’t shown up.\nSo, a heap memory profile for the find run was then needed. The run specifics of the end-to-end test in example was enough.\nMemory profiling: entering pprof Long story short, pprof is a standard library’s package that serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.\n I recommend the official documentation of the package, and this great Julia Evans' blog.\n So, I simply linked pprof package:\npackage find import ( /// ...  _ \"net/http/pprof\" // ... ) modified the tested function to run in parallel its webserver:\npackage find // ...  func (o *Options) Find() (*Result, error) { go func() { log.Println(http.ListenAndServe(\"localhost:6060\", nil)) }() if err := o.Validate(); err != nil { return nil, errors.Wrap(err, \"error validating find options\") } switch o.FileType { case FileTypeReg: return o.crawlFiles() case FileTypeDir: return o.crawlFolders() default: return o.crawlFiles() } } and finally run the tests again:\n$ ginkgo --focus \"File crawling\" pkg/find and immediately invoke the pprof go tool to download the heap memory profile as a PNG image:\n$ go tool pprof http://localhost:6060/debug/pprof/heap (pprof) png Generating report in profile001.png Looking at the profile function call graph it was evident that a great amount of memory mapping was request by a reading: io.ReadAll(), called from colly.Do():\nSo digging into the go-colly HTTP backend Do implementation, the offending line was:\npackage colly //...  func (h *httpBackend) Do(request *http.Request, bodySize int, checkHeadersFunc checkHeadersFunc) (*Response, error) { // ... \tres, err := h.Client.Do(request) if err != nil { return nil, err } defer res.Body.Close() // ... \tvar bodyReader io.Reader = res.Body if bodySize  0 { bodyReader = io.LimitReader(bodyReader, int64(bodySize)) } // ... \tbody, err := ioutil.ReadAll(bodyReader) // ... } So, a first solution was to limit the size of the response body which was being read.\nMax HTTP body size Fortunately, go-colly provides a way to set the requests' maximum body size that will be read, so I ended up exposing an option:\npackage find // Options represents the options for the Find job. type Options struct { // ... \t// MaxBodySize is the limit in bytes of each of the retrieved response body. \tMaxBodySize int // ... } which then would have fill the colly collector setting:\npackage find // ...  // crawlFiles returns a list of file names found from the seed URL, filtered by file name regex. func (o *Options) crawlFiles() (*Result, error) { // ...  // Create the collector settings \tcoOptions := []func(*colly.Collector){ // ... \tcolly.MaxBodySize(o.MaxBodySize), } Finally I updated the end-to-end test, tuning the parameter with an expected maximum value, considering the HTML nature of expected response body:\nvar _ = Describe(\"File crawling\", func() { Context(\"Async\", func() { var ( search = find.NewFind( find.WithAsync(true), find.WithSeedURLs([]string{seedURL}), find.WithFilenameRegexp(fileRegexp), find.WithFileType(find.FileTypeReg), find.WithRecursive(true), find.WithMaxBodySize(1024*512), find.WithConnTimeoutRetryBackOff(find.DefaultExponentialBackOffOptions), find.WithConnResetRetryBackOff(find.DefaultExponentialBackOffOptions), ) actual *find.Result err error expectedCount = expectedResults ) BeforeEach(func() { actual, err = search.Find() }) It(\"Should not fail\", func() { Expect(err).To(BeNil()) }) It(\"Should stage results\", func() { Expect(actual.URLs).ToNot(BeEmpty()) Expect(actual.URLs).ToNot(BeNil()) }) It(\"Should stage exact result count\", func() { Expect(len(actual.URLs)).To(Equal(expectedCount)) }) }) } and run again the tests:\n$ ginkgo --focus \"File crawling\" pkg/find ... Ran 3 of 3 Specs in 7.552 seconds SUCCESS! -- 3 Passed | 0 Failed | 0 Pending | 0 Skipped Now tests passed in just less than 8 seconds!\nMore tuning: HTTP client’s Transport Another important network and connection parameters are provided with the go net/http Transport. Connection timeout, TCP keep alive interval, TLS handshake timeout, Go net/http idle connnection pool maximum size, idle connections timeout are just some of them.\nThe connection pool size here is fundamental to be tuned in order to satisfy the level of concurrency enabled by the asynchronous mode of go-colly, hence of wfind.\nIn detail, Go net/http Get keeps the connection pool as a cache of TCP connections, but when all are in use it opens another one. If the parallelism is greater than the limit of idle connections, the program is going to be regularly discarding connections and opening new ones, the latters ending up in TIME_WAIT TCP state for two minutes, tying up that connection.\n About TIME_WAIT TCP state I recommend this blog by Vincent Bernat.\n From the Go standard library net/http package:\npackage http type Transport struct { // ...  // MaxIdleConns controls the maximum number of idle (keep-alive) \t// connections across all hosts. Zero means no limit. \tMaxIdleConns int // MaxIdleConnsPerHost, if non-zero, controls the maximum idle \t// (keep-alive) connections to keep per-host. If zero, \t// DefaultMaxIdleConnsPerHost is used. \tMaxIdleConnsPerHost int As so, it was very useful to provide way to inject a client Transport configured for specific use cases:\npackage find // Options represents the options for the Find job. type Options struct { // ...  // ClientTransport represents the Transport used for the HTTP client. \tClientTransport http.RoundTripper // ... } and in the go-colly collector to set up the client with the provided Transport:\npackage find // crawlFiles returns a list of file names found from the seed URL, filtered by file name regex. func (o *Options) crawlFiles() (*Result, error) { ... // Create the collector settings \tcoOptions := []func(*colly.Collector){ colly.AllowedDomains(allowedDomains...), colly.Async(o.Async), colly.MaxBodySize(o.MaxBodySize), } ... // Create the collector. \tco := colly.NewCollector(coOptions...) if o.ClientTransport != nil { co.WithTransport(o.ClientTransport) } Wrapping up As wfind main command is the first consumer, from its perspective, the command Run would consume it as so:\nfunc (o *Command) Run(_ *cobra.Command, args []string) error { ... // Network client dialer. \tdialer := network.NewDialer( network.WithTimeout(o.ConnectionTimeout), network.WithKeepAlive(o.KeepAliveInterval), ) // HTTP client transport. \ttransport := network.NewTransport( network.WithDialer(dialer), network.WithIdleConnsTimeout(o.IdleConnTimeout), network.WithTLSHandshakeTimeout(o.TLSHandshakeTimeout), network.WithMaxIdleConns(o.ConnPoolSize), network.WithMaxIdleConnsPerHost(o.ConnPoolPerHostSize), ) // Wfind finder. \tfinder := find.NewFind( find.WithSeedURLs(o.SeedURLs), find.WithFilenameRegexp(o.FilenameRegexp), find.WithFileType(o.FileType), find.WithRecursive(o.Recursive), find.WithVerbosity(o.Verbose), find.WithAsync(o.Async), find.WithClientTransport(transport), ) for which default command’s flag default values are provided by wfind for its specific use case.\nConclusion The retry logics allowed to provide consistency, and network and transport tuning in the HTTP client improved the efficiency and performance.\nAs usual, there’s alwasy something to learn and it’s cool how deep we can dig into things. I was curious about the reason why so much connections in TIME_WAIT state were left during the scraping, even if they’re not a problem. So learning how Go runtime manages the connections keeping a cache pool of them was the key to understand more and how to optimize the management in cases like this, where there may be high parallalism and probably high concurrency as well, on OS network stack’s resources.\nMoreover, I like Go every day more, as already the standard library provides often all you need with primitives, and in this case for network and for synchronization.\nThank you! I hope this was interesting for you as it was for me. Please, feel free to reach out!\nTwitter Mastodon Github Linkedin\n","wordCount":"2498","inLanguage":"en","datePublished":"2023-09-04T10:20:00+02:00","dateModified":"2023-09-04T10:20:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.maxgio.me/posts/improving-consistency-performance-go-crawler-retry-logics-http-client-tuning/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"https://blog.maxgio.me/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://blog.maxgio.me/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.maxgio.me/posts title=Posts><span>Posts</span></a></li><li><a href=https://blog.maxgio.me/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.maxgio.me/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/maxgio92 title=Github><span>Github</span></a></li><li><a href=https://hachyderm.io/@maxgio92 title=Mastodon><span>Mastodon</span></a></li><li><a href=https://twitter.com/maxgio92 title=Twitter><span>Twitter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.maxgio.me/>Home</a>&nbsp;»&nbsp;<a href=https://blog.maxgio.me/posts/>Posts</a></div><h1 class=post-title>How I improved consistency and performance in a Go crawler with retry logics and network tuning</h1><div class=post-meta><span title="2023-09-04 10:20:00 +0200 +0200">September 4, 2023</span>&nbsp;·&nbsp;12 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#parallelism-and-concurrency aria-label="Parallelism and concurrency">Parallelism and concurrency</a></li><li><a href=#end-to-end-tests aria-label="End-to-end tests">End-to-end tests</a></li><li><a href=#retry-logics aria-label="Retry logics">Retry logics</a><ul><li><a href=#dumb-retrier aria-label="Dumb retrier">Dumb retrier</a></li><li><a href=#retry-with-exponential-backoff aria-label="Retry with exponential backoff">Retry with exponential backoff</a></li></ul></li><li><a href=#memory-profiling-entering-pprof aria-label="Memory profiling: entering pprof">Memory profiling: entering pprof</a><ul><li><a href=#max-http-body-size aria-label="Max HTTP body size">Max HTTP body size</a></li></ul></li><li><a href=#more-tuning-http-clients-transport aria-label="More tuning: HTTP client&amp;rsquo;s Transport">More tuning: HTTP client&rsquo;s Transport</a></li><li><a href=#wrapping-up aria-label="Wrapping up">Wrapping up</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a><ul><li><a href=#thank-you aria-label="Thank you!">Thank you!</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p><a href=https://github.com/maxgio92/wfind>wfind</a> is a simple web crawler for files and folders in web pages hyerarchies. The goal is basically the same of <a href=https://www.gnu.org/software/findutils/manual/html_mono/find.html>GNU find</a> for file systems.
At the same time it&rsquo;s inspired by <a href=https://www.gnu.org/software/wget/manual/html_node/index.html>GNU wget</a>, and it merges the <code>find</code> features applied to files and directories exposed as HTML web resources.</p><p>In this blog we&rsquo;ll go through the way I improved consistency in this crawler, by implementing retry logics and tuning network and transport in the HTTP client.</p><h2 id=parallelism-and-concurrency>Parallelism and concurrency<a hidden class=anchor aria-hidden=true href=#parallelism-and-concurrency>#</a></h2><p>As a crawler, <code>wfind</code> is vital to efficiently do its work scraping web pages in parallel routines.</p><p>For scraping web pages wfind leverages <a href=https://go-colly.org/>go-colly</a>, that allows run its <a href=https://go-colly.org/docs/introduction/start/#collector>collector</a> in <a href=https://go-colly.org/docs/examples/parallel/>asynchronous mode</a>.
That mode simply <a href=https://github.com/gocolly/colly/blob/v2.1.0/colly.go#L440><code>fetches</code></a> HTTP objects inside <a href=https://github.com/gocolly/colly/blob/v2.1.0/colly.go#L573>dedicated goroutines</a>.</p><p>From the user perspective (i.e. <code>wfind</code>), the synchronization is as simple as invoking the <a href=https://github.com/gocolly/colly/blob/v2.1.0/colly.go#L812><code>Wait</code></a> function before completing.
The API is provided by the Colly collector and it wraps around the standard <a href=https://pkg.go.dev/sync#WaitGroup><code>WaitGroup</code></a>&rsquo;s <code>Wait()</code>, from the Go standard library&rsquo;s <a href=https://pkg.go.dev/sync><code>sync</code></a> package, waiting for all the fetch goroutines to complete.</p><p>As the go-colly implementation does not provide cap on the parallelism, the implementation can lead to the common concurrency problems, racing for OS and runtime resources client-side, server-side, and physical medium-side.</p><p>Client-side, the maxmimum allowed open connections could prevent the client to open and then establish new ones during the scraping.
The server could limit resource usage and we cannot predict the strategies and logics followed server-side.
Also, the connection mean in the physical layer is another point of failure; for example latency might cause the HTTP client to time out during go-colly&rsquo;s <a href=https://github.com/gocolly/colly/blob/v2.1.0/colly.go#L440C20-L440C27><code>Visit</code></a> waiting for a response.</p><p>At the end of the day a retry logics was fundamental in order to improve the consistency in the crawling.
Furthermore, verifying the consistency through end-to-end functional tests is required to guarantee the expected behaviour of the program.</p><h2 id=end-to-end-tests>End-to-end tests<a hidden class=anchor aria-hidden=true href=#end-to-end-tests>#</a></h2><p>As end-to-end functional tests treat the program as a black-box and ensures that provide the value as expected, interacting with the real actors in the expected scenarios, I wrote tests again real CentOS kernel.org mirrors, looking for repository metadata files, as an example use case of <code>wfind</code>.</p><p>I used <a href=https://onsi.github.io/ginkgo/>GinkGo</a> as I like how it easily enables to design and implement the specifications of the program as you write tests.</p><p>Moreover, regardless of whether or not you follow BDD, tests tend to appear self-explanatory.</p><p>Indeed, Ginkgo with Gomega matchers provide a DSL for writing tests in general like integration tests but also white-box and black-box unit tests.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find_test</span>

<span class=kn>import</span> <span class=p>(</span>
	<span class=p>.</span> <span class=s>&#34;github.com/onsi/ginkgo/v2&#34;</span>
	<span class=p>.</span> <span class=s>&#34;github.com/onsi/gomega&#34;</span>

	<span class=s>&#34;github.com/maxgio92/wfind/internal/network&#34;</span>
	<span class=s>&#34;github.com/maxgio92/wfind/pkg/find&#34;</span>
<span class=p>)</span>

<span class=kd>const</span> <span class=p>(</span>
	<span class=nx>seedURL</span>         <span class=p>=</span> <span class=s>&#34;https://mirrors.edge.kernel.org/centos/8-stream&#34;</span>
	<span class=nx>fileRegexp</span>      <span class=p>=</span> <span class=s>&#34;repomd.xml$&#34;</span>
	<span class=nx>expectedResults</span> <span class=p>=</span> <span class=mi>155</span>
<span class=p>)</span>

<span class=kd>var</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>Describe</span><span class=p>(</span><span class=s>&#34;File crawling&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
	<span class=nf>Context</span><span class=p>(</span><span class=s>&#34;Async&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=p>(</span>
			<span class=nx>search</span> <span class=p>=</span> <span class=nx>find</span><span class=p>.</span><span class=nf>NewFind</span><span class=p>(</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithAsync</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithSeedURLs</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=nx>seedURL</span><span class=p>}),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithFilenameRegexp</span><span class=p>(</span><span class=nx>fileRegexp</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithFileType</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>FileTypeReg</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithRecursive</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>
			<span class=p>)</span>
			<span class=nx>actual</span>        <span class=o>*</span><span class=nx>find</span><span class=p>.</span><span class=nx>Result</span>
			<span class=nx>err</span>           <span class=kt>error</span>
			<span class=nx>expectedCount</span> <span class=p>=</span> <span class=nx>expectedResults</span>
		<span class=p>)</span>
		<span class=nf>BeforeEach</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nx>actual</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>search</span><span class=p>.</span><span class=nf>Find</span><span class=p>()</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should not fail&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>To</span><span class=p>(</span><span class=nf>BeNil</span><span class=p>())</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should stage results&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>).</span><span class=nf>ToNot</span><span class=p>(</span><span class=nf>BeEmpty</span><span class=p>())</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>).</span><span class=nf>ToNot</span><span class=p>(</span><span class=nf>BeNil</span><span class=p>())</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should stage exact result count&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>)).</span><span class=nf>To</span><span class=p>(</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>expectedCount</span><span class=p>))</span>
		<span class=p>})</span>
	<span class=p>})</span>
<span class=p>})</span>
</code></pre></div><p>As you can see, the order in which results are returned is not important and thus not tested.</p><h2 id=retry-logics>Retry logics<a hidden class=anchor aria-hidden=true href=#retry-logics>#</a></h2><p>The first concrete goal of the retry logics was to start to see green flags from the GinkGo output.</p><p>So I expected to start by seeing tests to fail:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ ginkgo --focus <span class=s2>&#34;File crawling&#34;</span> pkg/find
...
FAIL! ...
</code></pre></div><p>Then, in order to make tests to pass, it was needed a way to ensure that requests failed would have been retried.</p><p>Fortunately go-colly provide way to register a callback, that as per the documentation it registers a function that will be executed if an error occurs during the HTTP request, with <a href=https://github.com/gocolly/colly/blob/v2.1.0/colly.go#L917><code>OnError</code></a>.</p><p>That way it&rsquo;s possible to run a custom handler as the response (and the request) object and the error are available in context of the helper, as for the <a href=https://github.com/gocolly/colly/blob/v2.1.0/colly.go#L146>signature</a>.</p><h3 id=dumb-retrier>Dumb retrier<a hidden class=anchor aria-hidden=true href=#dumb-retrier>#</a></h3><p>The first implementation of the retry could have been as simple as retry for a fixed amount of times, after a fixed amount of period.</p><p>For example:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=nx>collector</span><span class=p>.</span><span class=nf>OnError</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>resp</span> <span class=o>*</span><span class=nx>colly</span><span class=p>.</span><span class=nx>Response</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
  <span class=nx>resp</span><span class=p>.</span><span class=nx>Request</span><span class=p>.</span><span class=nf>Retry</span><span class=p>()</span>
<span class=p>})</span>
</code></pre></div><p>For sure this wasn&rsquo;t enough to improve the probability to make failing requests to succeed.</p><h3 id=retry-with-exponential-backoff>Retry with exponential backoff<a hidden class=anchor aria-hidden=true href=#retry-with-exponential-backoff>#</a></h3><p>At first, a single retry might not be enough, and also, the optimal backoff size should vary depending on the failure cause and the context. Furthermore, it would be good to be increased as time passes in order to avoid overload on the actors.</p><p>So I decided to leverage the community projects and digging around backoff implementations. After that, I picked and imported <a href=https://github.com/cenkalti/backoff><code>github.com/cenkalti/backoff</code></a> package.
I liked the design as it respects all the SOLID principles and because it provides API to a tunable exponential backoff algorithm. Also, it allows to mix and match with different custom backoff algorithms, without needing to implement a ticker.</p><p>Furthermore, I wanted to provide knobs to enable the retry behaviour for specific errors encountered doing HTTP requests. So I ended up including new dedicated options to the <code>wfind/pkg/find</code>&rsquo;s ones:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=c1>// ...
</span><span class=c1></span>
<span class=c1>// Options represents the options for the Find job.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Options</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=c1>// ConnResetRetryBackOff controls the error handling on responses.
</span><span class=c1></span>	<span class=c1>// If not nil, when the connection is reset by the peer (TCP RST), the request
</span><span class=c1></span>	<span class=c1>// is retried with an exponential backoff interval.
</span><span class=c1></span>	<span class=nx>ConnResetRetryBackOff</span> <span class=o>*</span><span class=nx>ExponentialBackOffOptions</span>

	<span class=c1>// TimeoutRetryBackOff controls the error handling on responses.
</span><span class=c1></span>	<span class=c1>// If not nil, when the connection times out (based on client timeout), the request
</span><span class=c1></span>	<span class=c1>// is retried with an exponential backoff interval.
</span><span class=c1></span>	<span class=nx>TimeoutRetryBackOff</span> <span class=o>*</span><span class=nx>ExponentialBackOffOptions</span>

	<span class=c1>// ContextDeadlineExceededRetryBackOff controls the error handling on responses.
</span><span class=c1></span>	<span class=c1>// If not nil, when the request context deadline exceeds, the request
</span><span class=c1></span>	<span class=c1>// is retried with an exponential backoff interval.
</span><span class=c1></span>	<span class=nx>ContextDeadlineExceededRetryBackOff</span> <span class=o>*</span><span class=nx>ExponentialBackOffOptions</span>
<span class=p>}</span>

<span class=c1>// ...
</span><span class=c1></span>
<span class=c1>// crawlFiles returns a list of file names found from the seed URL,
</span><span class=c1>// filtered by file name regex.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Options</span><span class=p>)</span> <span class=nf>crawlFiles</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>

	<span class=c1>// Create the collector.
</span><span class=c1></span>	<span class=nx>co</span> <span class=o>:=</span> <span class=nx>colly</span><span class=p>.</span><span class=nf>NewCollector</span><span class=p>(</span><span class=nx>coOptions</span><span class=o>...</span><span class=p>)</span>

	<span class=c1>// Add the callback to Visit the linked resource, for each HTML element found
</span><span class=c1></span>	<span class=nx>co</span><span class=p>.</span><span class=nf>OnHTML</span><span class=p>(</span><span class=nx>HTMLTagLink</span><span class=p>,</span> <span class=kd>func</span><span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>colly</span><span class=p>.</span><span class=nx>HTMLElement</span><span class=p>)</span> <span class=p>{</span>
		<span class=c1>// ...
</span><span class=c1></span>	<span class=p>})</span>

	<span class=c1>// Manage errors.
</span><span class=c1></span>	<span class=nx>co</span><span class=p>.</span><span class=nf>OnError</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>handleError</span><span class=p>)</span>

	<span class=c1>// ...
</span><span class=c1></span>
	<span class=c1>// Wait until colly goroutines are finished.
</span><span class=c1></span>	<span class=nx>co</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>

	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Result</span><span class=p>{</span><span class=nx>BaseNames</span><span class=p>:</span> <span class=nx>files</span><span class=p>,</span> <span class=nx>URLs</span><span class=p>:</span> <span class=nx>urls</span><span class=p>},</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// handleError handles an error received making a colly.Request.
</span><span class=c1>// It accepts a colly.Response and the error.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Options</span><span class=p>)</span> <span class=nf>handleError</span><span class=p>(</span><span class=nx>response</span> <span class=o>*</span><span class=nx>colly</span><span class=p>.</span><span class=nx>Response</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>switch</span> <span class=p>{</span>
	<span class=c1>// Context timed out.
</span><span class=c1></span>	<span class=k>case</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Is</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>context</span><span class=p>.</span><span class=nx>DeadlineExceeded</span><span class=p>):</span>
		<span class=k>if</span> <span class=nx>o</span><span class=p>.</span><span class=nx>ContextDeadlineExceededRetryBackOff</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nf>retryWithExponentialBackoff</span><span class=p>(</span><span class=nx>response</span><span class=p>.</span><span class=nx>Request</span><span class=p>.</span><span class=nx>Retry</span><span class=p>,</span> <span class=nx>o</span><span class=p>.</span><span class=nx>TimeoutRetryBackOff</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=c1>// Request has timed out.
</span><span class=c1></span>	<span class=k>case</span> <span class=nx>os</span><span class=p>.</span><span class=nf>IsTimeout</span><span class=p>(</span><span class=nx>err</span><span class=p>):</span>
		<span class=k>if</span> <span class=nx>o</span><span class=p>.</span><span class=nx>TimeoutRetryBackOff</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nf>retryWithExponentialBackoff</span><span class=p>(</span><span class=nx>response</span><span class=p>.</span><span class=nx>Request</span><span class=p>.</span><span class=nx>Retry</span><span class=p>,</span> <span class=nx>o</span><span class=p>.</span><span class=nx>TimeoutRetryBackOff</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=c1>// Connection has been reset (RST) by the peer.
</span><span class=c1></span>	<span class=k>case</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Is</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>ECONNRESET</span><span class=p>):</span>
		<span class=k>if</span> <span class=nx>o</span><span class=p>.</span><span class=nx>ConnResetRetryBackOff</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nf>retryWithExponentialBackoff</span><span class=p>(</span><span class=nx>response</span><span class=p>.</span><span class=nx>Request</span><span class=p>.</span><span class=nx>Retry</span><span class=p>,</span> <span class=nx>o</span><span class=p>.</span><span class=nx>ConnResetRetryBackOff</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=c1>// Other failures.
</span><span class=c1></span>	<span class=k>default</span><span class=p>:</span>
		<span class=c1>// ...
</span><span class=c1></span>	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>With the implementation of the retry leveraging the <code>cenkalti/backoff</code> package, following the <a href=https://github.com/cenkalti/backoff/blob/v4/example_test.go#L42C1-L71C2>example</a> provided:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=c1>// retryWithExtponentialBackoff retries with an exponential backoff a function.
</span><span class=c1>// Exponential backoff can be tuned with options accepted as arguments to the function.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>retryWithExponentialBackoff</span><span class=p>(</span><span class=nx>retryF</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>error</span><span class=p>,</span> <span class=nx>opts</span> <span class=o>*</span><span class=nx>ExponentialBackOffOptions</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>ticker</span> <span class=o>:=</span> <span class=nx>backoff</span><span class=p>.</span><span class=nf>NewTicker</span><span class=p>(</span>
		<span class=nx>utils</span><span class=p>.</span><span class=nf>NewExponentialBackOff</span><span class=p>(</span>
			<span class=nx>utils</span><span class=p>.</span><span class=nf>WithClock</span><span class=p>(</span><span class=nx>opts</span><span class=p>.</span><span class=nx>Clock</span><span class=p>),</span>
			<span class=nx>utils</span><span class=p>.</span><span class=nf>WithInitialInterval</span><span class=p>(</span><span class=nx>opts</span><span class=p>.</span><span class=nx>InitialInterval</span><span class=p>),</span>
			<span class=nx>utils</span><span class=p>.</span><span class=nf>WithMaxInterval</span><span class=p>(</span><span class=nx>opts</span><span class=p>.</span><span class=nx>MaxInterval</span><span class=p>),</span>
			<span class=nx>utils</span><span class=p>.</span><span class=nf>WithMaxElapsedTime</span><span class=p>(</span><span class=nx>opts</span><span class=p>.</span><span class=nx>MaxElapsedTime</span><span class=p>),</span>
		<span class=p>),</span>
	<span class=p>)</span>

	<span class=kd>var</span> <span class=nx>err</span> <span class=kt>error</span>

	<span class=c1>// Ticks will continue to arrive when the previous retryF is still running,
</span><span class=c1></span>	<span class=c1>// so operations that take a while to fail could run in quick succession.
</span><span class=c1></span>	<span class=k>for</span> <span class=k>range</span> <span class=nx>ticker</span><span class=p>.</span><span class=nx>C</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nf>retryF</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=c1>// Retry.
</span><span class=c1></span>			<span class=k>continue</span>
		<span class=p>}</span>

		<span class=nx>ticker</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
		<span class=k>break</span>
	<span class=p>}</span>

	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// Retry has failed.
</span><span class=c1></span>		<span class=k>return</span>
	<span class=p>}</span>

	<span class=c1>// Retry is successful.
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>And the end-to-end test could have been updated by enabling the retry behaviour for the context deadline exceeded, HTTP client transport&rsquo;s timeout, connection reset by peer cases:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>Describe</span><span class=p>(</span><span class=s>&#34;File crawling&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
	<span class=nf>Context</span><span class=p>(</span><span class=s>&#34;Async&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=p>(</span>
			<span class=nx>search</span> <span class=p>=</span> <span class=nx>find</span><span class=p>.</span><span class=nf>NewFind</span><span class=p>(</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithAsync</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithSeedURLs</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=nx>seedURL</span><span class=p>}),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithClientTransport</span><span class=p>(</span><span class=nx>network</span><span class=p>.</span><span class=nx>DefaultClientTransport</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithFilenameRegexp</span><span class=p>(</span><span class=nx>fileRegexp</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithFileType</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>FileTypeReg</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithRecursive</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>

				<span class=c1>// Enable retry backoff with default parameters.
</span><span class=c1></span>				<span class=nx>find</span><span class=p>.</span><span class=nf>WithContextDeadlineExceededRetryBackOff</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>DefaultExponentialBackOffOptions</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithConnTimeoutRetryBackOff</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>DefaultExponentialBackOffOptions</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithConnResetRetryBackOff</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>DefaultExponentialBackOffOptions</span><span class=p>),</span>
			<span class=p>)</span>
			<span class=nx>actual</span>        <span class=o>*</span><span class=nx>find</span><span class=p>.</span><span class=nx>Result</span>
			<span class=nx>err</span>           <span class=kt>error</span>
			<span class=nx>expectedCount</span> <span class=p>=</span> <span class=nx>expectedResults</span>
		<span class=p>)</span>
		<span class=nf>BeforeEach</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nx>actual</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>search</span><span class=p>.</span><span class=nf>Find</span><span class=p>()</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should not fail&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>To</span><span class=p>(</span><span class=nf>BeNil</span><span class=p>())</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should stage results&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>).</span><span class=nf>ToNot</span><span class=p>(</span><span class=nf>BeEmpty</span><span class=p>())</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>).</span><span class=nf>ToNot</span><span class=p>(</span><span class=nf>BeNil</span><span class=p>())</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should stage exact result count&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>)).</span><span class=nf>To</span><span class=p>(</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>expectedCount</span><span class=p>))</span>
		<span class=p>})</span>
	<span class=p>})</span>
<span class=p>})</span>
</code></pre></div><p>And I re-run the e2e test again:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ ginkgo --focus <span class=s2>&#34;File crawling&#34;</span> pkg/find
</code></pre></div><p>But the tests took too much time consuming a lot of memory until it was out-of-memory killed.
Likely a memory leak or simply not efficient memory management was already present, but without retry logics nor performance tests it hadn&rsquo;t shown up.</p><p>So, a heap memory profile for the find run was then needed. The run specifics of the end-to-end test in example was enough.</p><h2 id=memory-profiling-entering-pprof>Memory profiling: entering pprof<a hidden class=anchor aria-hidden=true href=#memory-profiling-entering-pprof>#</a></h2><p>Long story short, pprof is a standard library&rsquo;s package that serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</p><blockquote><p>I recommend the official documentation of the package, and this great <a href=https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/>Julia Evans' blog</a>.</p></blockquote><p>So, I simply linked pprof package:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=kn>import</span> <span class=p>(</span>
  <span class=c1>/// ...
</span><span class=c1></span>  <span class=nx>_</span> <span class=s>&#34;net/http/pprof&#34;</span>

  <span class=c1>// ...
</span><span class=c1></span><span class=p>)</span>
</code></pre></div><p>modified the tested function to run in parallel its webserver:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=c1>// ...
</span><span class=c1></span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Options</span><span class=p>)</span> <span class=nf>Find</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>http</span><span class=p>.</span><span class=nf>ListenAndServe</span><span class=p>(</span><span class=s>&#34;localhost:6060&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>))</span>
	<span class=p>}()</span>

	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>o</span><span class=p>.</span><span class=nf>Validate</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrap</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;error validating find options&#34;</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=k>switch</span> <span class=nx>o</span><span class=p>.</span><span class=nx>FileType</span> <span class=p>{</span>
	<span class=k>case</span> <span class=nx>FileTypeReg</span><span class=p>:</span>
		<span class=k>return</span> <span class=nx>o</span><span class=p>.</span><span class=nf>crawlFiles</span><span class=p>()</span>
	<span class=k>case</span> <span class=nx>FileTypeDir</span><span class=p>:</span>
		<span class=k>return</span> <span class=nx>o</span><span class=p>.</span><span class=nf>crawlFolders</span><span class=p>()</span>
	<span class=k>default</span><span class=p>:</span>
		<span class=k>return</span> <span class=nx>o</span><span class=p>.</span><span class=nf>crawlFiles</span><span class=p>()</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>and finally run the tests again:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ ginkgo --focus <span class=s2>&#34;File crawling&#34;</span> pkg/find
</code></pre></div><p>and immediately invoke the pprof go tool to download the heap memory profile as a PNG image:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ go tool pprof http://localhost:6060/debug/pprof/heap
<span class=o>(</span>pprof<span class=o>)</span> png
Generating report in profile001.png
</code></pre></div><p>Looking at the profile function call graph it was evident that a great amount of memory mapping was request by a reading: <code>io.ReadAll()</code>, called from <code>colly.Do()</code>:</p><p><img loading=lazy src=https://github.com/maxgio92/notes/assets/7593929/0e6da0f0-929d-456c-bc6f-ce5300750265 alt=image></p><p>So digging into the go-colly HTTP backend <code>Do</code> implementation, the <a href=https://github.com/gocolly/colly/blob/v2.1.0/http_backend.go#L209>offending line</a> was:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>colly</span>

<span class=c1>//...
</span><span class=c1></span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=o>*</span><span class=nx>httpBackend</span><span class=p>)</span> <span class=nf>Do</span><span class=p>(</span><span class=nx>request</span> <span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>,</span> <span class=nx>bodySize</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>checkHeadersFunc</span> <span class=nx>checkHeadersFunc</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Response</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>res</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>h</span><span class=p>.</span><span class=nx>Client</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>err</span>
	<span class=p>}</span>
	<span class=k>defer</span> <span class=nx>res</span><span class=p>.</span><span class=nx>Body</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=kd>var</span> <span class=nx>bodyReader</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Reader</span> <span class=p>=</span> <span class=nx>res</span><span class=p>.</span><span class=nx>Body</span>
	<span class=k>if</span> <span class=nx>bodySize</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nx>bodyReader</span> <span class=p>=</span> <span class=nx>io</span><span class=p>.</span><span class=nf>LimitReader</span><span class=p>(</span><span class=nx>bodyReader</span><span class=p>,</span> <span class=nb>int64</span><span class=p>(</span><span class=nx>bodySize</span><span class=p>))</span>
	<span class=p>}</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>body</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>ReadAll</span><span class=p>(</span><span class=nx>bodyReader</span><span class=p>)</span>
	<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>So, a first solution was to limit the size of the response body which was being read.</p><h3 id=max-http-body-size>Max HTTP body size<a hidden class=anchor aria-hidden=true href=#max-http-body-size>#</a></h3><p>Fortunately, go-colly provides a way to set the requests' maximum body size that will be read, so I ended up exposing an option:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=c1>// Options represents the options for the Find job.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Options</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=c1>// MaxBodySize is the limit in bytes of each of the retrieved response body.
</span><span class=c1></span>	<span class=nx>MaxBodySize</span> <span class=kt>int</span>
	<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>which then would have fill the colly collector setting:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=c1>// ...
</span><span class=c1></span>
<span class=c1>// crawlFiles returns a list of file names found from the seed URL, filtered by file name regex.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Options</span><span class=p>)</span> <span class=nf>crawlFiles</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=c1>// Create the collector settings
</span><span class=c1></span>	<span class=nx>coOptions</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>colly</span><span class=p>.</span><span class=nx>Collector</span><span class=p>){</span>
		<span class=c1>// ...
</span><span class=c1></span>		<span class=nx>colly</span><span class=p>.</span><span class=nf>MaxBodySize</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>MaxBodySize</span><span class=p>),</span>
	<span class=p>}</span>
</code></pre></div><p>Finally I updated the end-to-end test, tuning the parameter with an expected maximum value, considering the HTML nature of expected response body:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>var</span> <span class=nx>_</span> <span class=p>=</span> <span class=nf>Describe</span><span class=p>(</span><span class=s>&#34;File crawling&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
	<span class=nf>Context</span><span class=p>(</span><span class=s>&#34;Async&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=p>(</span>
			<span class=nx>search</span> <span class=p>=</span> <span class=nx>find</span><span class=p>.</span><span class=nf>NewFind</span><span class=p>(</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithAsync</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithSeedURLs</span><span class=p>([]</span><span class=kt>string</span><span class=p>{</span><span class=nx>seedURL</span><span class=p>}),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithFilenameRegexp</span><span class=p>(</span><span class=nx>fileRegexp</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithFileType</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>FileTypeReg</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithRecursive</span><span class=p>(</span><span class=kc>true</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithMaxBodySize</span><span class=p>(</span><span class=mi>1024</span><span class=o>*</span><span class=mi>512</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithConnTimeoutRetryBackOff</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>DefaultExponentialBackOffOptions</span><span class=p>),</span>
				<span class=nx>find</span><span class=p>.</span><span class=nf>WithConnResetRetryBackOff</span><span class=p>(</span><span class=nx>find</span><span class=p>.</span><span class=nx>DefaultExponentialBackOffOptions</span><span class=p>),</span>
			<span class=p>)</span>
			<span class=nx>actual</span>        <span class=o>*</span><span class=nx>find</span><span class=p>.</span><span class=nx>Result</span>
			<span class=nx>err</span>           <span class=kt>error</span>
			<span class=nx>expectedCount</span> <span class=p>=</span> <span class=nx>expectedResults</span>
		<span class=p>)</span>
		<span class=nf>BeforeEach</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nx>actual</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>search</span><span class=p>.</span><span class=nf>Find</span><span class=p>()</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should not fail&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>err</span><span class=p>).</span><span class=nf>To</span><span class=p>(</span><span class=nf>BeNil</span><span class=p>())</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should stage results&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>).</span><span class=nf>ToNot</span><span class=p>(</span><span class=nf>BeEmpty</span><span class=p>())</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>).</span><span class=nf>ToNot</span><span class=p>(</span><span class=nf>BeNil</span><span class=p>())</span>
		<span class=p>})</span>
		<span class=nf>It</span><span class=p>(</span><span class=s>&#34;Should stage exact result count&#34;</span><span class=p>,</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
			<span class=nf>Expect</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>actual</span><span class=p>.</span><span class=nx>URLs</span><span class=p>)).</span><span class=nf>To</span><span class=p>(</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>expectedCount</span><span class=p>))</span>
		<span class=p>})</span>
	<span class=p>})</span>
<span class=p>}</span>
</code></pre></div><p>and run again the tests:</p><div class=highlight><pre class=chroma><code class=language-shell data-lang=shell>$ ginkgo --focus <span class=s2>&#34;File crawling&#34;</span> pkg/find
...
Ran <span class=m>3</span> of <span class=m>3</span> Specs in 7.552 seconds
SUCCESS! -- <span class=m>3</span> Passed <span class=p>|</span> <span class=m>0</span> Failed <span class=p>|</span> <span class=m>0</span> Pending <span class=p>|</span> <span class=m>0</span> Skipped
</code></pre></div><p>Now tests passed in just less than 8 seconds!</p><h2 id=more-tuning-http-clients-transport>More tuning: HTTP client&rsquo;s Transport<a hidden class=anchor aria-hidden=true href=#more-tuning-http-clients-transport>#</a></h2><p>Another important network and connection parameters are provided with the go <a href=https://pkg.go.dev/net/http><code>net/http Transport</code></a>.
Connection timeout, TCP keep alive interval, TLS handshake timeout, Go net/http idle connnection pool maximum size, idle connections timeout are just some of them.</p><p>The <a href=https://github.com/golang/go/blob/go1.21.0/src/net/http/transport.go#L925>connection pool</a> size here is fundamental to be tuned in order to satisfy the level of concurrency enabled by the asynchronous mode of go-colly, hence of wfind.</p><p>In detail, Go <a href=https://pkg.go.dev/net/http><code>net/http</code></a> <code>Get</code> keeps the connection pool as a cache of TCP connections, but when all are in use it opens another one.
If the parallelism is greater than the limit of idle connections, the program is going to be <a href=https://github.com/golang/go/blob/go1.21.0/src/net/http/transport.go#L999>regularly discarding connections</a> and opening new ones, the latters ending up in <code>TIME_WAIT</code> TCP state for two minutes, tying up that connection.</p><blockquote><p>About <code>TIME_WAIT</code> TCP state I recommend <a href=https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux>this blog</a> by Vincent Bernat.</p></blockquote><p>From the Go standard library <a href=https://pkg.go.dev/net/http><code>net/http</code></a> package:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>http</span>

<span class=kd>type</span> <span class=nx>Transport</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=c1>// MaxIdleConns controls the maximum number of idle (keep-alive)
</span><span class=c1></span>	<span class=c1>// connections across all hosts. Zero means no limit.
</span><span class=c1></span>	<span class=nx>MaxIdleConns</span> <span class=kt>int</span>

	<span class=c1>// MaxIdleConnsPerHost, if non-zero, controls the maximum idle
</span><span class=c1></span>	<span class=c1>// (keep-alive) connections to keep per-host. If zero,
</span><span class=c1></span>	<span class=c1>// DefaultMaxIdleConnsPerHost is used.
</span><span class=c1></span>	<span class=nx>MaxIdleConnsPerHost</span> <span class=kt>int</span>
</code></pre></div><p>As so, it was very useful to provide way to inject a client Transport configured for specific use cases:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=c1>// Options represents the options for the Find job.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Options</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=c1>// ClientTransport represents the Transport used for the HTTP client.
</span><span class=c1></span>	<span class=nx>ClientTransport</span> <span class=nx>http</span><span class=p>.</span><span class=nx>RoundTripper</span>

	<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>and in the go-colly collector to set up the client with the provided Transport:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>find</span>

<span class=c1>// crawlFiles returns a list of file names found from the seed URL, filtered by file name regex.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Options</span><span class=p>)</span> <span class=nf>crawlFiles</span><span class=p>()</span> <span class=p>(</span><span class=o>*</span><span class=nx>Result</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=o>...</span>

	<span class=c1>// Create the collector settings
</span><span class=c1></span>	<span class=nx>coOptions</span> <span class=o>:=</span> <span class=p>[]</span><span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>colly</span><span class=p>.</span><span class=nx>Collector</span><span class=p>){</span>
		<span class=nx>colly</span><span class=p>.</span><span class=nf>AllowedDomains</span><span class=p>(</span><span class=nx>allowedDomains</span><span class=o>...</span><span class=p>),</span>
		<span class=nx>colly</span><span class=p>.</span><span class=nf>Async</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>Async</span><span class=p>),</span>
		<span class=nx>colly</span><span class=p>.</span><span class=nf>MaxBodySize</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>MaxBodySize</span><span class=p>),</span>
	<span class=p>}</span>

	<span class=o>...</span>

	<span class=c1>// Create the collector.
</span><span class=c1></span>	<span class=nx>co</span> <span class=o>:=</span> <span class=nx>colly</span><span class=p>.</span><span class=nf>NewCollector</span><span class=p>(</span><span class=nx>coOptions</span><span class=o>...</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>o</span><span class=p>.</span><span class=nx>ClientTransport</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=nx>co</span><span class=p>.</span><span class=nf>WithTransport</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>ClientTransport</span><span class=p>)</span>
	<span class=p>}</span>
</code></pre></div><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>As <code>wfind</code> main command is the first consumer, from its perspective, the command <code>Run</code> would consume it as so:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=p>(</span><span class=nx>o</span> <span class=o>*</span><span class=nx>Command</span><span class=p>)</span> <span class=nf>Run</span><span class=p>(</span><span class=nx>_</span> <span class=o>*</span><span class=nx>cobra</span><span class=p>.</span><span class=nx>Command</span><span class=p>,</span> <span class=nx>args</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=o>...</span>

	<span class=c1>// Network client dialer.
</span><span class=c1></span>	<span class=nx>dialer</span> <span class=o>:=</span> <span class=nx>network</span><span class=p>.</span><span class=nf>NewDialer</span><span class=p>(</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>ConnectionTimeout</span><span class=p>),</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithKeepAlive</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>KeepAliveInterval</span><span class=p>),</span>
	<span class=p>)</span>

	<span class=c1>// HTTP client transport.
</span><span class=c1></span>	<span class=nx>transport</span> <span class=o>:=</span> <span class=nx>network</span><span class=p>.</span><span class=nf>NewTransport</span><span class=p>(</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithDialer</span><span class=p>(</span><span class=nx>dialer</span><span class=p>),</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithIdleConnsTimeout</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>IdleConnTimeout</span><span class=p>),</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithTLSHandshakeTimeout</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>TLSHandshakeTimeout</span><span class=p>),</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithMaxIdleConns</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>ConnPoolSize</span><span class=p>),</span>
		<span class=nx>network</span><span class=p>.</span><span class=nf>WithMaxIdleConnsPerHost</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>ConnPoolPerHostSize</span><span class=p>),</span>
	<span class=p>)</span>

	<span class=c1>// Wfind finder.
</span><span class=c1></span>	<span class=nx>finder</span> <span class=o>:=</span> <span class=nx>find</span><span class=p>.</span><span class=nf>NewFind</span><span class=p>(</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithSeedURLs</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>SeedURLs</span><span class=p>),</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithFilenameRegexp</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>FilenameRegexp</span><span class=p>),</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithFileType</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>FileType</span><span class=p>),</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithRecursive</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>Recursive</span><span class=p>),</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithVerbosity</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>Verbose</span><span class=p>),</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithAsync</span><span class=p>(</span><span class=nx>o</span><span class=p>.</span><span class=nx>Async</span><span class=p>),</span>
		<span class=nx>find</span><span class=p>.</span><span class=nf>WithClientTransport</span><span class=p>(</span><span class=nx>transport</span><span class=p>),</span>
	<span class=p>)</span>
</code></pre></div><p>for which default command&rsquo;s flag default values are provided by wfind for its specific use case.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>The retry logics allowed to provide consistency, and network and transport tuning in the HTTP client improved the efficiency and performance.</p><p>As usual, there&rsquo;s alwasy something to learn and it&rsquo;s cool how deep we can dig into things. I was curious about the reason why so much connections in <code>TIME_WAIT</code> state were left during the scraping, even if they&rsquo;re not a problem. So learning how Go runtime manages the connections keeping a cache pool of them was the key to understand more and how to optimize the management in cases like this, where there may be high parallalism and probably high concurrency as well, on OS network stack&rsquo;s resources.</p><p>Moreover, I like Go every day more, as already the standard library provides often all you need with primitives, and in this case for network and for synchronization.</p><h3 id=thank-you>Thank you!<a hidden class=anchor aria-hidden=true href=#thank-you>#</a></h3><p>I hope this was interesting for you as it was for me. Please, feel free to reach out!</p><p><a href=https://twitter.com/maxgio92>Twitter</a>
<a href=https://hachyderm.io/@maxgio92>Mastodon</a>
<a href=https://github.com/maxgio92>Github</a>
<a href=https://linkedin.com/in/maxgio>Linkedin</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.maxgio.me/tags/go/>go</a></li><li><a href=https://blog.maxgio.me/tags/performance/>performance</a></li><li><a href=https://blog.maxgio.me/tags/consistency/>consistency</a></li><li><a href=https://blog.maxgio.me/tags/optimization/>optimization</a></li></ul><nav class=paginav><a class=prev href=https://blog.maxgio.me/posts/unleashing-power-frame-poiners-execution-environment/><span class=title>« Prev</span><br><span>Unleashing the power of frame pointers pt.1 - The execution environment</span></a>
<a class=next href=https://blog.maxgio.me/posts/linux-scheduler-journey/><span class=title>Next »</span><br><span>A journey into the Linux scheduler</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How I improved consistency and performance in a Go crawler with retry logics and network tuning on twitter" href="https://twitter.com/intent/tweet/?text=How%20I%20improved%20consistency%20and%20performance%20in%20a%20Go%20crawler%20with%20retry%20logics%20and%20network%20tuning&url=https%3a%2f%2fblog.maxgio.me%2fposts%2fimproving-consistency-performance-go-crawler-retry-logics-http-client-tuning%2f&hashtags=go%2cperformance%2cconsistency%2coptimization"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share How I improved consistency and performance in a Go crawler with retry logics and network tuning on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.maxgio.me%2fposts%2fimproving-consistency-performance-go-crawler-retry-logics-http-client-tuning%2f&title=How%20I%20improved%20consistency%20and%20performance%20in%20a%20Go%20crawler%20with%20retry%20logics%20and%20network%20tuning&summary=How%20I%20improved%20consistency%20and%20performance%20in%20a%20Go%20crawler%20with%20retry%20logics%20and%20network%20tuning&source=https%3a%2f%2fblog.maxgio.me%2fposts%2fimproving-consistency-performance-go-crawler-retry-logics-http-client-tuning%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.maxgio.me/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>