<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>STRIDE threat modeling on Kubernetes pt.1/6: Spoofing</title><link rel=stylesheet href=/css/style.css></head><body><header><h2><a href=http://maxgio92.github.io/>Maxgio's blog</a></h2><br><div style=float:right>Notes that I'd want to share with you</div><br><p><nav><a href=/><b>Home</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>STRIDE threat modeling on Kubernetes pt.1/6: Spoofing</h1><b><time>2020-02-03 18:36:15</time></b><div><p>As it comes from the power of the open source and Borg, Kubernetes is an ecosystem very flexible. Only the extensibility of the APIs as for the CRDs opens the world to a vastity of opportunities to build architectures upon it (see the SIG&rsquo;s Cluster API, the AWS EKS and Fargate combinations, etc.).</p><p>At the same time can be complex to manage, and everyone - or almost everyone - knows that is not enough to get applications working; as part of the administration it is vital to secure your cluster and so your application with your data to get the job done.</p><p>In security, the threat modeling is the process of identifying vulnerabilities to improve security by preventing the threats introduced by vulnerabilities.</p><p>In turn, there are different types of threats and the STRIDE model defines 6 categories of them:</p><ul><li>Spoofing</li><li>Tampering</li><li>Repudiation</li><li>Information disclosure</li><li>Denial of service</li><li>Elevation of privilege</li></ul><p>In this series of short and concise guide for threat prevention on Kubernetes, we&rsquo;ll go through each category of threat starting with the first one.</p><h1 id=spoofing>Spoofing</h1><p>Spoofing is pretending to be somebody or something you are not, to gain extra privileges. The process that makes sure the presented identity is real is the authentication, and in Kubernetes the authentication is based on mutual TLS.</p><p>We briefly analyze the situation from the API Server perspective and the Pod perspective.</p><h2 id=api-server>API Server</h2><p>Starting with the API Server, the mTLS is only as secure as the Certificate Authority, so:</p><ul><li>The CA must be secured, so in particular:</li><li>the certificates issued by the CA must be used and trusted only within the cluster;
outside of Kubernetes the CA should not be trusted.</li><li>Use two key pairs, one for internal components and one for external components, in particular:</li><li>use self-signed CA for internal keys;</li><li>third-party CA(s) for external components' certificates; in this case Kubernetes must be configured to trust it/them.</li></ul><h2 id=pod>Pod</h2><p>On the pod perspective, mostly it probably does not need to access the API Server, in which case:</p><ul><li>since pods use Service Account to authenticate to the API server and be authorized by mounting the Service Account token as a Secret, don&rsquo;t mount it on Pods by default. In particular, with Kubernetes 1.6+, specifying it at the Pod level with the automountServiceAccountToken spec:</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>serviceAccountName</span>: <span style=color:#ae81ff>build-robot</span>
  <span style=color:#f92672>automountServiceAccountToken</span>: <span style=color:#66d9ef>false</span>
</code></pre></div><p>You can configure it also at the Service Account level; keep in mind that the Pod Spec takes precedence over the Service Account if both specify a automountServiceAccountToken value.</p><p>This is the end of the first pill of this series. Stay tuned for the next part.</p><p>Happy hacking!</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/k8s-stride-05-denial-of-service/>STRIDE threat modeling on Kubernetes pt.5/6: Denial of service</a></li><li><a href=/posts/k8s-stride-04-information-disclosure/>STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure</a></li><li><a href=/posts/k8s-stride-03-repudiation/>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</a></li><li><a href=/posts/k8s-stride-02-tampering/>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</a></li><li><a href=/posts/k8s-stride-01-spoofing/>STRIDE threat modeling on Kubernetes pt.1/6: Spoofing</a></li></ul></div></div></aside><footer><p>&copy; 2021 <a href=http://maxgio92.github.io/><b>Maxgio's blog</b></a>.
<a href=https://github.com/maxgio92><b>Github</b></a>.
<a href=https://twitter.com/maxgio92><b>Twitter</b></a>.</p></footer></body></html>