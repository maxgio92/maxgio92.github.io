<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STRIDE threat modeling on Kubernetes pt.2/6: Tampering | Maxgio's blog</title><meta name=keywords content="kubernetes,security"><meta name=description content="In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: Tampering.
Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.
Generally for preventing tampering is important to:
 limit the access to critical components; control the access to critical components;  Furthermore, it&rsquo;s important to watch for evidence of tampering."><meta name=author content><link rel=canonical href=http://maxgio92.github.io/posts/k8s-stride-02-tampering/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=http://maxgio92.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://maxgio92.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://maxgio92.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://maxgio92.github.io/apple-touch-icon.png><link rel=mask-icon href=http://maxgio92.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-7DN0LVS78Q','auto');ga('send','pageview');}</script><meta property="og:title" content="STRIDE threat modeling on Kubernetes pt.2/6: Tampering"><meta property="og:description" content="In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: Tampering.
Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.
Generally for preventing tampering is important to:
 limit the access to critical components; control the access to critical components;  Furthermore, it&rsquo;s important to watch for evidence of tampering."><meta property="og:type" content="article"><meta property="og:url" content="http://maxgio92.github.io/posts/k8s-stride-02-tampering/"><meta property="og:image" content="http://maxgio92.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-11T18:36:15+02:00"><meta property="article:modified_time" content="2020-02-11T18:36:15+02:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://maxgio92.github.io/papermod-cover.png"><meta name=twitter:title content="STRIDE threat modeling on Kubernetes pt.2/6: Tampering"><meta name=twitter:description content="In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: Tampering.
Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.
Generally for preventing tampering is important to:
 limit the access to critical components; control the access to critical components;  Furthermore, it&rsquo;s important to watch for evidence of tampering."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://maxgio92.github.io/posts/"},{"@type":"ListItem","position":2,"name":"STRIDE threat modeling on Kubernetes pt.2/6: Tampering","item":"http://maxgio92.github.io/posts/k8s-stride-02-tampering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STRIDE threat modeling on Kubernetes pt.2/6: Tampering","name":"STRIDE threat modeling on Kubernetes pt.2\/6: Tampering","description":"In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we\u0026rsquo;ll talk about the T of STRIDE: Tampering.\nTampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.\nGenerally for preventing tampering is important to:\n limit the access to critical components; control the access to critical components;  Furthermore, it\u0026rsquo;s important to watch for evidence of tampering.","keywords":["kubernetes","security"],"articleBody":"In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we’ll talk about the T of STRIDE: Tampering.\nTampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.\nGenerally for preventing tampering is important to:\n limit the access to critical components; control the access to critical components;  Furthermore, it’s important to watch for evidence of tampering.\nGenerally, a common solution to highlight instances of tampering could be using seals, but let’s apply these concepts to the Kubernetes world.\nLimit access Control plane To protect data at rest, restrict access to master nodes to protect data on etcd. Furthermore, encrypt etcd data, especially Secrets.\nTo protect data in transit, TLS guarantees privacy besides integrity. The communication from the cluster to the API Server is TLS-encrypted (see here to secure traffic to the API Server).\nData plane From the developer perspective - even if the line is not so clear - set containers root filesystem to read-only using SecurityContexts, at container or pod level, since the data that needs to be written is usually persisted through volumes:\napiVersion:v1kind:Podmetadata:name:my-secure-podspec:containers:# ...securityContext:readOnlyRootFilesystem:true# ...From the administrator perspective, the best defense against data tampering is to validate data before processing it. For example the vulnerability CVE-2019–11253 was found last year and this is the related issue on GitHub, there are also described recommended mitigation actions.\nYou can validate pods through Pod Security Policies. They are implemented as an additional Admission Controller and you can prevent for:\n creating Pods with non read only root filesystems: apiVersion:policy/v1beta1kind:PodSecurityPolicymetadata:name:my-psp-ro-rootfs# ...spec:# ...readOnlyRootFilesystem:false# ... creating Pods that access host filesystem to not allowed paths through hostPath volumes, by specifying a whitelist of host paths that are allowed to be used by hostPath volumes: apiVersion:policy/v1beta1kind:PodSecurityPolicymetadata:name:my-psp-hostpaths# ...spec:# ...allowedHostPaths:- pathPrefix:\"/example\"readOnly:true# ...  Important: Remember to authorize the policies before enabling the Pod Security Policy admission controller, otherwise it will prevent any pods from being created in the cluster. See here to know how to do it.\nOther than PSP you can configure Open Policy Agent that is an open source, general-purpose policy engine that unifies policy enforcement; OPA GateKeeper integrates OPA with Kubernetes.\nApplication Restrict access to the container images' registry. For example, on AWS you can enforce IAM policies on ECR repositories.\nConfiguration Restrict access to the repositories of the configuration files. It can be obvious but do not store sensitive data on repositories, instead use Secrets. Moreover, evaluate if you need a secrets manager such as Vault; you can use it to inject Secrets through sidecars.\nControl access Enable auditing on Kubernetes binaries. Furthermore, you can leverage additional security solutions like Falco, an eBPF-powered OSS for cloud native runtime security that is now part of the CNCF.\nI recommend to see this session to see how it can capture potentially abnormal system events through its set of rules and send them to its audit endpoint through Kubernetes Webhooks.\nIt can be installed standalone or as a DaemonSet; follow this guide to know how to install and use it.\nWatch for evidence of tampering Verify downloaded binaries for the container runtime by running SHA-2 checksum. For the purpose of the conciseness of this post I don’t talk about it here, but you can read this simple howto.\nThat’s all for this part, thank you and stay tuned for the next one.\nHappy hacking!\n","wordCount":"563","inLanguage":"en","datePublished":"2020-02-11T18:36:15+02:00","dateModified":"2020-02-11T18:36:15+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://maxgio92.github.io/posts/k8s-stride-02-tampering/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"http://maxgio92.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=http://maxgio92.github.io/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://maxgio92.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=http://maxgio92.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://maxgio92.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/maxgio92 title=Github><span>Github</span></a></li><li><a href=https://hachyderm.io/@maxgio92 title=Mastodon><span>Mastodon</span></a></li><li><a href=https://twitter.com/maxgio92 title=Twitter><span>Twitter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://maxgio92.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://maxgio92.github.io/posts/>Posts</a></div><h1 class=post-title>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</h1><div class=post-meta><span title="2020-02-11 18:36:15 +0200 +0200">February 11, 2020</span>&nbsp;·&nbsp;3 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#limit-access aria-label="Limit access">Limit access</a><ul><li><a href=#control-plane aria-label="Control plane">Control plane</a></li><li><a href=#data-plane aria-label="Data plane">Data plane</a><ul><li><a href=#application aria-label=Application>Application</a></li><li><a href=#configuration aria-label=Configuration>Configuration</a></li></ul></li></ul></li><li><a href=#control-access aria-label="Control access">Control access</a></li><li><a href=#watch-for-evidence-of-tampering aria-label="Watch for evidence of tampering">Watch for evidence of tampering</a></li></ul></div></details></div><div class=post-content><p>In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: <strong>Tampering</strong>.</p><p>Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.</p><p>Generally for preventing tampering is important to:</p><ul><li>limit the access to critical components;</li><li>control the access to critical components;</li></ul><p>Furthermore, it&rsquo;s important to watch for evidence of tampering.</p><p>Generally, a common solution to highlight instances of tampering could be using seals, but let&rsquo;s apply these concepts to the Kubernetes world.</p><h1 id=limit-access>Limit access<a hidden class=anchor aria-hidden=true href=#limit-access>#</a></h1><h2 id=control-plane>Control plane<a hidden class=anchor aria-hidden=true href=#control-plane>#</a></h2><p>To protect data at rest, <a href=https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/#controlling-access-to-the-kubernetes-api>restrict access</a> to master nodes to protect data on etcd. Furthermore, <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>encrypt</a> etcd data, especially Secrets.</p><p>To protect data in transit, TLS guarantees privacy besides integrity.
The communication from the cluster to the API Server is TLS-encrypted (see here to secure traffic to the API Server).</p><h2 id=data-plane>Data plane<a hidden class=anchor aria-hidden=true href=#data-plane>#</a></h2><p>From the developer perspective - even if the line is not so clear - set containers root filesystem to read-only using SecurityContexts, at container or pod level, since the data that needs to be written is usually persisted through volumes:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-secure-pod</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span><span class=w>  </span><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>readOnlyRootFilesystem</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>    </span><span class=c># ...</span><span class=w>
</span></code></pre></div><p>From the administrator perspective, the best defense against data tampering is to validate data before processing it. For example the vulnerability <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11253">CVE-2019–11253</a> was found last year and this is the <a href=https://github.com/kubernetes/kubernetes/issues/83253>related issue</a> on GitHub, there are also described recommended mitigation actions.</p><p>You can validate pods through <a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>Pod Security Policies</a>. They are implemented as an additional <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy>Admission Controller</a> and you can prevent for:</p><ul><li>creating Pods with non read only root filesystems:<div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=w>  
</span><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>policy/v1beta1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PodSecurityPolicy</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-psp-ro-rootfs</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span><span class=w>  </span><span class=nt>readOnlyRootFilesystem</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span></code></pre></div></li><li>creating Pods that access host filesystem to not allowed paths through hostPath volumes, by specifying a whitelist of host paths that are allowed to be used by hostPath volumes:<div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>policy/v1beta1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PodSecurityPolicy</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-psp-hostpaths</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span><span class=w>  </span><span class=nt>allowedHostPaths</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>pathPrefix</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/example&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>readOnly</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>  </span><span class=c># ...</span><span class=w>
</span></code></pre></div></li></ul><p><strong>Important</strong>: Remember to authorize the policies before enabling the Pod Security Policy admission controller, otherwise it will prevent any pods from being created in the cluster. See <a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/#authorizing-policies>here</a> to know how to do it.</p><p>Other than PSP you can configure <a href=https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/>Open Policy Agent</a> that is an open source, general-purpose policy engine that unifies policy enforcement; <a href=https://kubernetes.io/blog/2019/08/06/opa-gatekeeper-policy-and-governance-for-kubernetes/>OPA GateKeeper</a> integrates OPA with Kubernetes.</p><h3 id=application>Application<a hidden class=anchor aria-hidden=true href=#application>#</a></h3><p>Restrict access to the container images' registry. For example, on AWS you can enforce IAM policies on ECR repositories.</p><h3 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h3><p>Restrict access to the repositories of the configuration files. It can be obvious but do not store sensitive data on repositories, instead use Secrets. Moreover, evaluate if you need a secrets manager such as <a href=https://www.vaultproject.io/>Vault</a>; you can use it to <a href=https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar>inject Secrets</a> through sidecars.</p><h1 id=control-access>Control access<a hidden class=anchor aria-hidden=true href=#control-access>#</a></h1><p><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/>Enable auditing</a> on Kubernetes binaries. Furthermore, you can leverage additional security solutions like <a href=https://falco.org/>Falco</a>, an <a href=https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/>eBPF-powered</a> OSS for cloud native runtime security that is now part of the CNCF.</p><p>I recommend to see <a href=https://asciinema.org/a/246326>this session</a> to see how it can capture potentially abnormal system events through its set of <a href=https://falco.org/docs/examples/>rules</a> and send them to its audit endpoint through Kubernetes <a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/>Webhooks</a>.</p><p>It can be installed standalone or as a DaemonSet; follow <a href=https://falco.org/docs/installation/>this guide</a> to know how to install and use it.</p><h1 id=watch-for-evidence-of-tampering>Watch for evidence of tampering<a hidden class=anchor aria-hidden=true href=#watch-for-evidence-of-tampering>#</a></h1><p>Verify downloaded binaries for the container runtime by running SHA-2 checksum. For the purpose of the conciseness of this post I don&rsquo;t talk about it here, but you can read this simple <a href=https://linuxconfig.org/how-to-verify-checksums-in-linux>howto</a>.</p><p>That&rsquo;s all for this part, thank you and stay tuned for the next one.</p><p>Happy hacking!</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://maxgio92.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=http://maxgio92.github.io/tags/security/>security</a></li></ul><nav class=paginav><a class=prev href=http://maxgio92.github.io/posts/k8s-stride-03-repudiation/><span class=title>« Prev</span><br><span>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</span></a>
<a class=next href=http://maxgio92.github.io/posts/k8s-stride-01-spoofing/><span class=title>Next »</span><br><span>STRIDE threat modeling on Kubernetes pt.1/6: Spoofing</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share STRIDE threat modeling on Kubernetes pt.2/6: Tampering on twitter" href="https://twitter.com/intent/tweet/?text=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.2%2f6%3a%20Tampering&url=http%3a%2f%2fmaxgio92.github.io%2fposts%2fk8s-stride-02-tampering%2f&hashtags=kubernetes%2csecurity"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share STRIDE threat modeling on Kubernetes pt.2/6: Tampering on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fmaxgio92.github.io%2fposts%2fk8s-stride-02-tampering%2f&title=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.2%2f6%3a%20Tampering&summary=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.2%2f6%3a%20Tampering&source=http%3a%2f%2fmaxgio92.github.io%2fposts%2fk8s-stride-02-tampering%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://maxgio92.github.io/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>