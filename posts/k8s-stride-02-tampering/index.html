<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</title><link rel=stylesheet href=/css/style.css></head><body><header><h2><a href=http://maxgio92.github.io/>Maxgio's blog</a></h2><br><div style=float:right>Notes that I'd want to share with you</div><br><p><nav><a href=/><b>Home</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</h1><b><time>2020-02-11 18:36:15</time></b>
<a href=/tags/kubernetes>kubernetes</a>
<a href=/tags/security>security</a><div><p>In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: <strong>Tampering</strong>.</p><p>Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.</p><p>Generally for preventing tampering is important to:</p><ul><li>limit the access to critical components;</li><li>control the access to critical components;</li></ul><p>Furthermore, it&rsquo;s important to watch for evidence of tampering.</p><p>Generally, a common solution to highlight instances of tampering could be using seals, but let&rsquo;s apply these concepts to the Kubernetes world.</p><h1 id=limit-access>Limit access</h1><h2 id=control-plane>Control plane</h2><p>To protect data at rest, <a href=https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/#controlling-access-to-the-kubernetes-api>restrict access</a> to master nodes to protect data on etcd. Furthermore, <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>encrypt</a> etcd data, especially Secrets.</p><p>To protect data in transit, TLS guarantees privacy besides integrity.
The communication from the cluster to the API Server is TLS-encrypted (see here to secure traffic to the API Server).</p><h2 id=data-plane>Data plane</h2><p>From the developer perspective - even if the line is not so clear - set containers root filesystem to read-only using SecurityContexts, at container or pod level, since the data that needs to be written is usually persisted through volumes:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-secure-pod</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  <span style=color:#75715e># ...</span>
  <span style=color:#f92672>securityContext</span>:
    <span style=color:#f92672>readOnlyRootFilesystem</span>: <span style=color:#66d9ef>true</span>
    <span style=color:#75715e># ...</span>
</code></pre></div><p>From the administrator perspective, the best defense against data tampering is to validate data before processing it. For example the vulnerability <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11253">CVE-2019–11253</a> was found last year and this is the <a href=https://github.com/kubernetes/kubernetes/issues/83253>related issue</a> on GitHub, there are also described recommended mitigation actions.</p><p>You can validate pods through <a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>Pod Security Policies</a>. They are implemented as an additional <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy>Admission Controller</a> and you can prevent for:</p><ul><li>creating Pods with non read only root filesystems:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  
<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>policy/v1beta1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PodSecurityPolicy</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-psp-ro-rootfs</span>
  <span style=color:#75715e># ...</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#75715e># ...</span>
  <span style=color:#f92672>readOnlyRootFilesystem</span>: <span style=color:#66d9ef>false</span>
  <span style=color:#75715e># ...</span>
</code></pre></div></li><li>creating Pods that access host filesystem to not allowed paths through hostPath volumes, by specifying a whitelist of host paths that are allowed to be used by hostPath volumes:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>policy/v1beta1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PodSecurityPolicy</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-psp-hostpaths</span>
  <span style=color:#75715e># ...</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#75715e># ...</span>
  <span style=color:#f92672>allowedHostPaths</span>:
    - <span style=color:#f92672>pathPrefix</span>: <span style=color:#e6db74>&#34;/example&#34;</span>
      <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
  <span style=color:#75715e># ...</span>
</code></pre></div></li></ul><p><strong>Important</strong>: Remember to authorize the policies before enabling the Pod Security Policy admission controller, otherwise it will prevent any pods from being created in the cluster. See <a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/#authorizing-policies>here</a> to know how to do it.</p><p>Other than PSP you can configure <a href=https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/>Open Policy Agent</a> that is an open source, general-purpose policy engine that unifies policy enforcement; <a href=https://kubernetes.io/blog/2019/08/06/opa-gatekeeper-policy-and-governance-for-kubernetes/>OPA GateKeeper</a> integrates OPA with Kubernetes.</p><h3 id=application>Application</h3><p>Restrict access to the container images' registry. For example, on AWS you can enforce IAM policies on ECR repositories.</p><h3 id=configuration>Configuration</h3><p>Restrict access to the repositories of the configuration files. It can be obvious but do not store sensitive data on repositories, instead use Secrets. Moreover, evaluate if you need a secrets manager such as <a href=https://www.vaultproject.io/>Vault</a>; you can use it to <a href=https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar>inject Secrets</a> through sidecars.</p><h1 id=control-access>Control access</h1><p><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/>Enable auditing</a> on Kubernetes binaries. Furthermore, you can leverage additional security solutions like <a href=https://falco.org/>Falco</a>, an <a href=https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/>eBPF-powered</a> OSS for cloud native runtime security that is now part of the CNCF.</p><p>I recommend to see <a href=https://asciinema.org/a/246326>this session</a> to see how it can capture potentially abnormal system events through its set of <a href=https://falco.org/docs/examples/>rules</a> and send them to its audit endpoint through Kubernetes <a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/>Webhooks</a>.</p><p>It can be installed standalone or as a DaemonSet; follow <a href=https://falco.org/docs/installation/>this guide</a> to know how to install and use it.</p><h1 id=watch-for-evidence-of-tampering>Watch for evidence of tampering</h1><p>Verify downloaded binaries for the container runtime by running SHA-2 checksum. For the purpose of the conciseness of this post I don&rsquo;t talk about it here, but you can read this simple <a href=https://linuxconfig.org/how-to-verify-checksums-in-linux>howto</a>.</p><p>That&rsquo;s all for this part, thank you and stay tuned for the next one.</p><p>Happy hacking!</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/stride-threat-modeling-kubernetes-elevation-of-privileges/>STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege</a></li><li><a href=/posts/k8s-stride-05-denial-of-service/>STRIDE threat modeling on Kubernetes pt.5/6: Denial of service</a></li><li><a href=/posts/k8s-stride-04-information-disclosure/>STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure</a></li><li><a href=/posts/k8s-stride-03-repudiation/>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</a></li><li><a href=/posts/k8s-stride-02-tampering/>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</a></li></ul></div></div></aside><footer><p>&copy; 2022 <a href=http://maxgio92.github.io/><b>Maxgio's blog</b></a>.
<a href=https://github.com/maxgio92><b>Github</b></a>.
<a href=https://twitter.com/maxgio92><b>Twitter</b></a>.</p></footer></body></html>