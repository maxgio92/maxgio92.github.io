<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STRIDE threat modeling on Kubernetes pt.2/6: Tampering | Maxgio's blog</title><meta name=keywords content="kubernetes,security"><meta name=description content="In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: Tampering.
Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.
Generally for preventing tampering is important to:
 limit the access to critical components; control the access to critical components;  Furthermore, it&rsquo;s important to watch for evidence of tampering."><meta name=author content><link rel=canonical href=http://maxgio92.github.io/posts/k8s-stride-02-tampering/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=http://maxgio92.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://maxgio92.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://maxgio92.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://maxgio92.github.io/apple-touch-icon.png><link rel=mask-icon href=http://maxgio92.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="STRIDE threat modeling on Kubernetes pt.2/6: Tampering"><meta property="og:description" content="In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: Tampering.
Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.
Generally for preventing tampering is important to:
 limit the access to critical components; control the access to critical components;  Furthermore, it&rsquo;s important to watch for evidence of tampering."><meta property="og:type" content="article"><meta property="og:url" content="http://maxgio92.github.io/posts/k8s-stride-02-tampering/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-11T18:36:15+02:00"><meta property="article:modified_time" content="2020-02-11T18:36:15+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="STRIDE threat modeling on Kubernetes pt.2/6: Tampering"><meta name=twitter:description content="In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: Tampering.
Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.
Generally for preventing tampering is important to:
 limit the access to critical components; control the access to critical components;  Furthermore, it&rsquo;s important to watch for evidence of tampering."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://maxgio92.github.io/posts/"},{"@type":"ListItem","position":2,"name":"STRIDE threat modeling on Kubernetes pt.2/6: Tampering","item":"http://maxgio92.github.io/posts/k8s-stride-02-tampering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STRIDE threat modeling on Kubernetes pt.2/6: Tampering","name":"STRIDE threat modeling on Kubernetes pt.2\/6: Tampering","description":"In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we\u0026rsquo;ll talk about the T of STRIDE: Tampering.\nTampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.\nGenerally for preventing tampering is important to:\n limit the access to critical components; control the access to critical components;  Furthermore, it\u0026rsquo;s important to watch for evidence of tampering.","keywords":["kubernetes","security"],"articleBody":"In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we’ll talk about the T of STRIDE: Tampering.\nTampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.\nGenerally for preventing tampering is important to:\n limit the access to critical components; control the access to critical components;  Furthermore, it’s important to watch for evidence of tampering.\nGenerally, a common solution to highlight instances of tampering could be using seals, but let’s apply these concepts to the Kubernetes world.\nLimit access Control plane To protect data at rest, restrict access to master nodes to protect data on etcd. Furthermore, encrypt etcd data, especially Secrets.\nTo protect data in transit, TLS guarantees privacy besides integrity. The communication from the cluster to the API Server is TLS-encrypted (see here to secure traffic to the API Server).\nData plane From the developer perspective - even if the line is not so clear - set containers root filesystem to read-only using SecurityContexts, at container or pod level, since the data that needs to be written is usually persisted through volumes:\napiVersion: v1 kind: Pod metadata: name: my-secure-pod spec: containers: # ... securityContext: readOnlyRootFilesystem: true # ... From the administrator perspective, the best defense against data tampering is to validate data before processing it. For example the vulnerability CVE-2019–11253 was found last year and this is the related issue on GitHub, there are also described recommended mitigation actions.\nYou can validate pods through Pod Security Policies. They are implemented as an additional Admission Controller and you can prevent for:\n creating Pods with non read only root filesystems: apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata: name: my-psp-ro-rootfs # ... spec: # ... readOnlyRootFilesystem: false # ...  creating Pods that access host filesystem to not allowed paths through hostPath volumes, by specifying a whitelist of host paths that are allowed to be used by hostPath volumes: apiVersion: policy/v1beta1 kind: PodSecurityPolicy metadata: name: my-psp-hostpaths # ... spec: # ... allowedHostPaths: - pathPrefix: \"/example\" readOnly: true # ...   Important: Remember to authorize the policies before enabling the Pod Security Policy admission controller, otherwise it will prevent any pods from being created in the cluster. See here to know how to do it.\nOther than PSP you can configure Open Policy Agent that is an open source, general-purpose policy engine that unifies policy enforcement; OPA GateKeeper integrates OPA with Kubernetes.\nApplication Restrict access to the container images' registry. For example, on AWS you can enforce IAM policies on ECR repositories.\nConfiguration Restrict access to the repositories of the configuration files. It can be obvious but do not store sensitive data on repositories, instead use Secrets. Moreover, evaluate if you need a secrets manager such as Vault; you can use it to inject Secrets through sidecars.\nControl access Enable auditing on Kubernetes binaries. Furthermore, you can leverage additional security solutions like Falco, an eBPF-powered OSS for cloud native runtime security that is now part of the CNCF.\nI recommend to see this session to see how it can capture potentially abnormal system events through its set of rules and send them to its audit endpoint through Kubernetes Webhooks.\nIt can be installed standalone or as a DaemonSet; follow this guide to know how to install and use it.\nWatch for evidence of tampering Verify downloaded binaries for the container runtime by running SHA-2 checksum. For the purpose of the conciseness of this post I don’t talk about it here, but you can read this simple howto.\nThat’s all for this part, thank you and stay tuned for the next one.\nHappy hacking!\n","wordCount":"604","inLanguage":"en","datePublished":"2020-02-11T18:36:15+02:00","dateModified":"2020-02-11T18:36:15+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://maxgio92.github.io/posts/k8s-stride-02-tampering/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"http://maxgio92.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=http://maxgio92.github.io/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://maxgio92.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://maxgio92.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://maxgio92.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</h1><div class=post-meta><span title="2020-02-11 18:36:15 +0200 +0200">February 11, 2020</span></div></header><div class=post-content><p>In the previous post of this little series we talked about preventing spoofing on Kubernetes. Today we&rsquo;ll talk about the T of STRIDE: <strong>Tampering</strong>.</p><p>Tampering is the act of changing something in a malicious way, to gain extra privileges or for denial of service.</p><p>Generally for preventing tampering is important to:</p><ul><li>limit the access to critical components;</li><li>control the access to critical components;</li></ul><p>Furthermore, it&rsquo;s important to watch for evidence of tampering.</p><p>Generally, a common solution to highlight instances of tampering could be using seals, but let&rsquo;s apply these concepts to the Kubernetes world.</p><h1 id=limit-access>Limit access<a hidden class=anchor aria-hidden=true href=#limit-access>#</a></h1><h2 id=control-plane>Control plane<a hidden class=anchor aria-hidden=true href=#control-plane>#</a></h2><p>To protect data at rest, <a href=https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/#controlling-access-to-the-kubernetes-api>restrict access</a> to master nodes to protect data on etcd. Furthermore, <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>encrypt</a> etcd data, especially Secrets.</p><p>To protect data in transit, TLS guarantees privacy besides integrity.
The communication from the cluster to the API Server is TLS-encrypted (see here to secure traffic to the API Server).</p><h2 id=data-plane>Data plane<a hidden class=anchor aria-hidden=true href=#data-plane>#</a></h2><p>From the developer perspective - even if the line is not so clear - set containers root filesystem to read-only using SecurityContexts, at container or pod level, since the data that needs to be written is usually persisted through volumes:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-secure-pod</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  <span style=color:#75715e># ...</span>
  <span style=color:#f92672>securityContext</span>:
    <span style=color:#f92672>readOnlyRootFilesystem</span>: <span style=color:#66d9ef>true</span>
    <span style=color:#75715e># ...</span>
</code></pre></div><p>From the administrator perspective, the best defense against data tampering is to validate data before processing it. For example the vulnerability <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11253">CVE-2019–11253</a> was found last year and this is the <a href=https://github.com/kubernetes/kubernetes/issues/83253>related issue</a> on GitHub, there are also described recommended mitigation actions.</p><p>You can validate pods through <a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>Pod Security Policies</a>. They are implemented as an additional <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy>Admission Controller</a> and you can prevent for:</p><ul><li>creating Pods with non read only root filesystems:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>  
<span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>policy/v1beta1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PodSecurityPolicy</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-psp-ro-rootfs</span>
  <span style=color:#75715e># ...</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#75715e># ...</span>
  <span style=color:#f92672>readOnlyRootFilesystem</span>: <span style=color:#66d9ef>false</span>
  <span style=color:#75715e># ...</span>
</code></pre></div></li><li>creating Pods that access host filesystem to not allowed paths through hostPath volumes, by specifying a whitelist of host paths that are allowed to be used by hostPath volumes:<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>policy/v1beta1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>PodSecurityPolicy</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-psp-hostpaths</span>
  <span style=color:#75715e># ...</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#75715e># ...</span>
  <span style=color:#f92672>allowedHostPaths</span>:
    - <span style=color:#f92672>pathPrefix</span>: <span style=color:#e6db74>&#34;/example&#34;</span>
      <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
  <span style=color:#75715e># ...</span>
</code></pre></div></li></ul><p><strong>Important</strong>: Remember to authorize the policies before enabling the Pod Security Policy admission controller, otherwise it will prevent any pods from being created in the cluster. See <a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/#authorizing-policies>here</a> to know how to do it.</p><p>Other than PSP you can configure <a href=https://www.openpolicyagent.org/docs/latest/kubernetes-introduction/>Open Policy Agent</a> that is an open source, general-purpose policy engine that unifies policy enforcement; <a href=https://kubernetes.io/blog/2019/08/06/opa-gatekeeper-policy-and-governance-for-kubernetes/>OPA GateKeeper</a> integrates OPA with Kubernetes.</p><h3 id=application>Application<a hidden class=anchor aria-hidden=true href=#application>#</a></h3><p>Restrict access to the container images' registry. For example, on AWS you can enforce IAM policies on ECR repositories.</p><h3 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h3><p>Restrict access to the repositories of the configuration files. It can be obvious but do not store sensitive data on repositories, instead use Secrets. Moreover, evaluate if you need a secrets manager such as <a href=https://www.vaultproject.io/>Vault</a>; you can use it to <a href=https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar>inject Secrets</a> through sidecars.</p><h1 id=control-access>Control access<a hidden class=anchor aria-hidden=true href=#control-access>#</a></h1><p><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/>Enable auditing</a> on Kubernetes binaries. Furthermore, you can leverage additional security solutions like <a href=https://falco.org/>Falco</a>, an <a href=https://sysdig.com/blog/sysdig-and-falco-now-powered-by-ebpf/>eBPF-powered</a> OSS for cloud native runtime security that is now part of the CNCF.</p><p>I recommend to see <a href=https://asciinema.org/a/246326>this session</a> to see how it can capture potentially abnormal system events through its set of <a href=https://falco.org/docs/examples/>rules</a> and send them to its audit endpoint through Kubernetes <a href=https://kubernetes.io/docs/reference/access-authn-authz/webhook/>Webhooks</a>.</p><p>It can be installed standalone or as a DaemonSet; follow <a href=https://falco.org/docs/installation/>this guide</a> to know how to install and use it.</p><h1 id=watch-for-evidence-of-tampering>Watch for evidence of tampering<a hidden class=anchor aria-hidden=true href=#watch-for-evidence-of-tampering>#</a></h1><p>Verify downloaded binaries for the container runtime by running SHA-2 checksum. For the purpose of the conciseness of this post I don&rsquo;t talk about it here, but you can read this simple <a href=https://linuxconfig.org/how-to-verify-checksums-in-linux>howto</a>.</p><p>That&rsquo;s all for this part, thank you and stay tuned for the next one.</p><p>Happy hacking!</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://maxgio92.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=http://maxgio92.github.io/tags/security/>security</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://maxgio92.github.io/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>