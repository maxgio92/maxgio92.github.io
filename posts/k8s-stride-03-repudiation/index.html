<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><style type=text/css>body{font-family:monospace}</style><title>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</title><link rel=stylesheet href=/css/style.css></head><body><header><h2><a href=http://maxgio92.github.io/>Maxgio's blog</a></h2><br><div style=float:right>Notes that I'd want to share with you</div><br><p><nav><a href=/><b>Home</b></a>.
<a href=/posts/><b>Posts</b></a>.
<a href=/categories/><b>Categories</b></a>.
<a href=/tags/><b>Tags</b></a>.</nav></p></header><main><article><h1>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</h1><b><time>2020-02-23 18:36:15</time></b>
<a href=/tags/kubernetes>kubernetes</a>
<a href=/tags/security>security</a><div><p>Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about <strong>Repudiation</strong>.</p><p>Repudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.</p><p>Generally the opposite and thus the desired goal is prooving:</p><ul><li>What</li><li>When</li><li>Where</li><li>Why</li><li>Who</li><li>How</li></ul><p>on certain actions. Non-repudiation refers to a situation where a statement&rsquo;s author cannot successfully dispute its authorship and involves associating actions or changes with a unique individual.</p><p>So, we can mitigate the risks by enabling auditing on the Kubernetes components and gain visibility on actions performed by individual users, administrators or components of the system.</p><p>Let&rsquo;s split out the components into two categories:</p><ul><li>Kubernetes components</li><li>Underline components</li></ul><h1 id=kubernetes-components>Kubernetes components</h1><h2 id=api-server>API Server</h2><p>As the focal point to the API and the front end of the control plane, kube-apiserver performs auditing on the requests and for each of them, it generates an event.</p><p>Each event is then pre-processed according to a policy and then written to a backend.</p><p>The policy determines what&rsquo;s recorded and the backend persists the records, which can be log files or webhooks.</p><p>Each request can be recorded with an associated stage, which are:</p><ul><li><code>RequestReceived</code> - The stage for events generated as soon as the audit handler receives the request, and before it is delegated down the handler chain.</li><li><code>ResponseStarted</code> - Once the response headers are sent, but before the response body is sent. This stage is only generated for long-running requests (e.g. watch).</li><li><code>ResponseComplete</code> - The response body has been completed and no more bytes will be sent.
Panic - Events generated when a panic occurred.</li></ul><h3 id=audit-policy>Audit Policy</h3><p>When an event is processed, it&rsquo;s compared against the list of rules of the Audit Policy in order. The first matching rule sets the audit level of the event.</p><p>In order to enable a policy, you can pass the policy file to the kube-apiserver command using the - <code>audit-policy-file</code> flag.</p><p>Is important to note that configuring a correct policy is crucial, so when configuring your own audit policy is recommended to refer to the GCE policy:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>audit.k8s.io/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Policy</span>
<span style=color:#f92672>rules</span>:
  <span style=color:#75715e># The following requests were manually identified as high-volume and low-risk,</span>
  <span style=color:#75715e># so drop them.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:kube-proxy&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;watch&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;endpoints&#34;</span>, <span style=color:#e6db74>&#34;services&#34;</span>, <span style=color:#e6db74>&#34;services/status&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#75715e># Ingress controller reads &#39;configmaps/ingress-uid&#39; through the unsecured port.</span>
    <span style=color:#75715e># TODO(#46983): Change this to the ingress controller service account.</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:unsecured&#34;</span>]
    <span style=color:#f92672>namespaces</span>: [<span style=color:#e6db74>&#34;kube-system&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;configmaps&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;kubelet&#34;</span>] <span style=color:#75715e># legacy kubelet identity</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes&#34;</span>, <span style=color:#e6db74>&#34;nodes/status&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>userGroups</span>: [<span style=color:#e6db74>&#34;system:nodes&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes&#34;</span>, <span style=color:#e6db74>&#34;nodes/status&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>:
      - <span style=color:#ae81ff>system:kube-controller-manager</span>
      - <span style=color:#ae81ff>system:kube-scheduler</span>
      - <span style=color:#ae81ff>system:serviceaccount:kube-system:endpoint-controller</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;update&#34;</span>]
    <span style=color:#f92672>namespaces</span>: [<span style=color:#e6db74>&#34;kube-system&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;endpoints&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:apiserver&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;namespaces&#34;</span>, <span style=color:#e6db74>&#34;namespaces/status&#34;</span>, <span style=color:#e6db74>&#34;namespaces/finalize&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;cluster-autoscaler&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;update&#34;</span>]
    <span style=color:#f92672>namespaces</span>: [<span style=color:#e6db74>&#34;kube-system&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;configmaps&#34;</span>, <span style=color:#e6db74>&#34;endpoints&#34;</span>]
  <span style=color:#75715e># Don&#39;t log HPA fetching metrics.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>:
      - <span style=color:#ae81ff>system:kube-controller-manager</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;metrics.k8s.io&#34;</span>
  <span style=color:#75715e># Don&#39;t log these read-only URLs.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>nonResourceURLs</span>:
      - <span style=color:#ae81ff>/healthz*</span>
      - <span style=color:#ae81ff>/version</span>
      - <span style=color:#ae81ff>/swagger*</span>
  <span style=color:#75715e># Don&#39;t log events requests.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;events&#34;</span>]
  <span style=color:#75715e># node and pod status calls from nodes are high-volume and can be large, don&#39;t log responses for expected updates from nodes</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;kubelet&#34;</span>, <span style=color:#e6db74>&#34;system:node-problem-detector&#34;</span>, <span style=color:#e6db74>&#34;system:serviceaccount:kube-system:node-problem-detector&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;update&#34;</span>,<span style=color:#e6db74>&#34;patch&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes/status&#34;</span>, <span style=color:#e6db74>&#34;pods/status&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>userGroups</span>: [<span style=color:#e6db74>&#34;system:nodes&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;update&#34;</span>,<span style=color:#e6db74>&#34;patch&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes/status&#34;</span>, <span style=color:#e6db74>&#34;pods/status&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># deletecollection calls can be large, don&#39;t log responses for expected namespace deletions</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:serviceaccount:kube-system:namespace-controller&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;deletecollection&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Secrets, ConfigMaps, and TokenReviews can contain sensitive &amp; binary data,</span>
  <span style=color:#75715e># so only log at the Metadata level.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Metadata</span>
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;secrets&#34;</span>, <span style=color:#e6db74>&#34;configmaps&#34;</span>]
      - <span style=color:#f92672>group</span>: <span style=color:#ae81ff>authentication.k8s.io</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;tokenreviews&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Get repsonses can be large; skip them.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>, <span style=color:#e6db74>&#34;watch&#34;</span>]
    <span style=color:#f92672>resources</span>: <span style=color:#ae81ff>${known_apis}</span>
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Default level for known APIs</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>RequestResponse</span>
    <span style=color:#f92672>resources</span>: <span style=color:#ae81ff>${known_apis}</span>
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Default level for all other requests.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Metadata</span>
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
</code></pre></div><p>Note also that the Audit Policy stands in the <a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/apis/audit/v1/types.go>audit.k8s.io</a> API group and the current version is v1.</p><h3 id=audit-backend>Audit Backend</h3><p>Audit backends persist audit events to an external storage. Kube-apiserver out of the box provides three backends:</p><ul><li><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#log-backend>Log backend</a>, which writes audit events to a file in JSON format;</li><li><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#webhook-backend>Webhook backend</a>, which sends audit events to a remote API, which is assumed to be the same API as kube-apiserver exposes;</li><li><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#dynamic-backend>Dynamic backend</a>, which configures webhook backends through an AuditSink API object.</li></ul><p>Both logging and webhook backend support <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#batching>batching</a> (enabled by default in webhook and disabled in log), for example to buffer events and asynchronously process them (In this case take <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#parameter-tuning>tuning</a> into account); they support also <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#truncate>truncation</a>.</p><h2 id=other-kubernetes-components>Other Kubernetes components</h2><p>Generally, the <code>kubelet</code> and container runtime write logs to journald, on machines with systemd. If systemd is not present, they write to .log files in the /var/log directory.
System components inside containers like the kube-scheduler and the kube-proxy always write to the <code>/var/log</code> directory, bypassing the default logging mechanism.</p><h1 id=underline-components>Underline components</h1><p>Once covered the high level of the stack is important to audit also the underline components, from the container logs to the syscalls.</p><h2 id=container-logs>Container logs</h2><p>Generally speaking, in order to decouple at scale the logging system from the application a standard interface to log streams should be used, and what&rsquo;s more standard of the standard streams?</p><p>I recommended writing container logs to stdout and stderr also because is handled and redirected somewhere by the container engine. For example, the Docker container engine redirects those two streams to a logging driver, which is configured in Kubernetes to write to a file in json form.</p><h2 id=syscalls>Syscalls</h2><p>Instead, speaking of system calls <a href=https://falco.org>Falco</a> can detect and alert on any behavior that involves making Linux system calls. For example, you can easily detect when:</p><ul><li>A shell is run inside a container</li><li>A server process spawns a child process of an unexpected type</li><li>A sensitive file, like /etc/shadow, is unexpectedly read</li><li>A non-device file is written to /dev</li><li>A standard system binary (like ls) makes an outbound network connection</li></ul><p>Falco is deployed as a long-running daemon and is configured via a general <a href=https://falco.org/docs/configuration/>configuration file</a> and a <a href=https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml>rules file</a> that is meant to be tailored to needs. <a href=https://falco.org/docs/examples/>Here</a> you can see example rules that can detect anomalous events.</p><p>When Falco detects suspicious behavior, it sends alerts via one or more channels:</p><ul><li>Writing to standard error</li><li>Writing to a file</li><li>Writing to syslog</li><li>Pipe to a spawned program. A common use of this output type would be to send an email for every Falco notification.</li></ul><p>One difference between Falco and other tools is that Falco runs in userspace, using a kernel module and eBPF probes to obtain system calls and bring them to userspace, while the other tools perform system call filtering/monitoring at the kernel level; thanks to that it can have a much richer set of information powering its policies.</p><p>Beyond system calls Falco&rsquo;s event sources can be also Kubernetes Events that are filtered through these rules. For this purpose, it exposes a webhook endpoint that can be used as a Kubernetes Audit webhook backend.</p><p>In order to install and configure it please refer to the official docs.</p><h1 id=logs-management>Logs management</h1><p>As for all logs, it is important to collect them and possibly ship them to a centralized and secured log store, available for further process.</p><p>Different shipping and collecting tools can be leveraged, such as <a href=https://www.fluentd.org/>fluentd</a> and <a href=https://www.elastic.co/logstash>logstash</a>. We&rsquo;ll not deepen about it here for conciseness.</p><h1 id=conclusion>Conclusion</h1><p>This post is not intended to provide the truth, instead to provide insights from my point of view. I purposely did not cover the auditing implementations of the cloud providers, to shift the focus on the fundamentals.</p><p>I hope it was interesting for you, if you liked it please let me know, if you don&rsquo;t agree please let me know, I appreciate sharing opinions and I always aim to learn something new and from different points of view!</p><p>For this post that&rsquo;s all, happy hacking!</p></div></article></main><aside><div><div><h3>LATEST POSTS</h3></div><div><ul><li><a href=/posts/k8s-stride-05-denial-of-service/>STRIDE threat modeling on Kubernetes pt.5/6: Denial of service</a></li><li><a href=/posts/k8s-stride-04-information-disclosure/>STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure</a></li><li><a href=/posts/k8s-stride-03-repudiation/>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</a></li><li><a href=/posts/k8s-stride-02-tampering/>STRIDE threat modeling on Kubernetes pt.2/6: Tampering</a></li><li><a href=/posts/k8s-stride-01-spoofing/>STRIDE threat modeling on Kubernetes pt.1/6: Spoofing</a></li></ul></div></div></aside><footer><p>&copy; 2021 <a href=http://maxgio92.github.io/><b>Maxgio's blog</b></a>.
<a href=https://github.com/maxgio92><b>Github</b></a>.
<a href=https://twitter.com/maxgio92><b>Twitter</b></a>.</p></footer></body></html>