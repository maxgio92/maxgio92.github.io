<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation | Maxgio's blog</title><meta name=keywords content="kubernetes,security"><meta name=description content="Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about Repudiation.
Repudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.
Generally the opposite and thus the desired goal is prooving:
 What When Where Why Who How  on certain actions."><meta name=author content><link rel=canonical href=http://maxgio92.github.io/posts/k8s-stride-03-repudiation/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=http://maxgio92.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://maxgio92.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://maxgio92.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://maxgio92.github.io/apple-touch-icon.png><link rel=mask-icon href=http://maxgio92.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="STRIDE threat modeling on Kubernetes pt.3/6: Repudiation"><meta property="og:description" content="Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about Repudiation.
Repudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.
Generally the opposite and thus the desired goal is prooving:
 What When Where Why Who How  on certain actions."><meta property="og:type" content="article"><meta property="og:url" content="http://maxgio92.github.io/posts/k8s-stride-03-repudiation/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-23T18:36:15+02:00"><meta property="article:modified_time" content="2020-02-23T18:36:15+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="STRIDE threat modeling on Kubernetes pt.3/6: Repudiation"><meta name=twitter:description content="Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about Repudiation.
Repudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.
Generally the opposite and thus the desired goal is prooving:
 What When Where Why Who How  on certain actions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://maxgio92.github.io/posts/"},{"@type":"ListItem","position":2,"name":"STRIDE threat modeling on Kubernetes pt.3/6: Repudiation","item":"http://maxgio92.github.io/posts/k8s-stride-03-repudiation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STRIDE threat modeling on Kubernetes pt.3/6: Repudiation","name":"STRIDE threat modeling on Kubernetes pt.3\/6: Repudiation","description":"Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about Repudiation.\nRepudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.\nGenerally the opposite and thus the desired goal is prooving:\n What When Where Why Who How  on certain actions.","keywords":["kubernetes","security"],"articleBody":"Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about Repudiation.\nRepudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.\nGenerally the opposite and thus the desired goal is prooving:\n What When Where Why Who How  on certain actions. Non-repudiation refers to a situation where a statement’s author cannot successfully dispute its authorship and involves associating actions or changes with a unique individual.\nSo, we can mitigate the risks by enabling auditing on the Kubernetes components and gain visibility on actions performed by individual users, administrators or components of the system.\nLet’s split out the components into two categories:\n Kubernetes components Underline components  Kubernetes components API Server As the focal point to the API and the front end of the control plane, kube-apiserver performs auditing on the requests and for each of them, it generates an event.\nEach event is then pre-processed according to a policy and then written to a backend.\nThe policy determines what’s recorded and the backend persists the records, which can be log files or webhooks.\nEach request can be recorded with an associated stage, which are:\n RequestReceived - The stage for events generated as soon as the audit handler receives the request, and before it is delegated down the handler chain. ResponseStarted - Once the response headers are sent, but before the response body is sent. This stage is only generated for long-running requests (e.g. watch). ResponseComplete - The response body has been completed and no more bytes will be sent. Panic - Events generated when a panic occurred.  Audit Policy When an event is processed, it’s compared against the list of rules of the Audit Policy in order. The first matching rule sets the audit level of the event.\nIn order to enable a policy, you can pass the policy file to the kube-apiserver command using the - audit-policy-file flag.\nIs important to note that configuring a correct policy is crucial, so when configuring your own audit policy is recommended to refer to the GCE policy:\napiVersion: audit.k8s.io/v1 kind: Policy rules: # The following requests were manually identified as high-volume and low-risk, # so drop them. - level: None users: [\"system:kube-proxy\"] verbs: [\"watch\"] resources: - group: \"\" # core resources: [\"endpoints\", \"services\", \"services/status\"] - level: None # Ingress controller reads 'configmaps/ingress-uid' through the unsecured port. # TODO(#46983): Change this to the ingress controller service account. users: [\"system:unsecured\"] namespaces: [\"kube-system\"] verbs: [\"get\"] resources: - group: \"\" # core resources: [\"configmaps\"] - level: None users: [\"kubelet\"] # legacy kubelet identity verbs: [\"get\"] resources: - group: \"\" # core resources: [\"nodes\", \"nodes/status\"] - level: None userGroups: [\"system:nodes\"] verbs: [\"get\"] resources: - group: \"\" # core resources: [\"nodes\", \"nodes/status\"] - level: None users: - system:kube-controller-manager - system:kube-scheduler - system:serviceaccount:kube-system:endpoint-controller verbs: [\"get\", \"update\"] namespaces: [\"kube-system\"] resources: - group: \"\" # core resources: [\"endpoints\"] - level: None users: [\"system:apiserver\"] verbs: [\"get\"] resources: - group: \"\" # core resources: [\"namespaces\", \"namespaces/status\", \"namespaces/finalize\"] - level: None users: [\"cluster-autoscaler\"] verbs: [\"get\", \"update\"] namespaces: [\"kube-system\"] resources: - group: \"\" # core resources: [\"configmaps\", \"endpoints\"] # Don't log HPA fetching metrics. - level: None users: - system:kube-controller-manager verbs: [\"get\", \"list\"] resources: - group: \"metrics.k8s.io\" # Don't log these read-only URLs. - level: None nonResourceURLs: - /healthz* - /version - /swagger* # Don't log events requests. - level: None resources: - group: \"\" # core resources: [\"events\"] # node and pod status calls from nodes are high-volume and can be large, don't log responses for expected updates from nodes - level: Request users: [\"kubelet\", \"system:node-problem-detector\", \"system:serviceaccount:kube-system:node-problem-detector\"] verbs: [\"update\",\"patch\"] resources: - group: \"\" # core resources: [\"nodes/status\", \"pods/status\"] omitStages: - \"RequestReceived\" - level: Request userGroups: [\"system:nodes\"] verbs: [\"update\",\"patch\"] resources: - group: \"\" # core resources: [\"nodes/status\", \"pods/status\"] omitStages: - \"RequestReceived\" # deletecollection calls can be large, don't log responses for expected namespace deletions - level: Request users: [\"system:serviceaccount:kube-system:namespace-controller\"] verbs: [\"deletecollection\"] omitStages: - \"RequestReceived\" # Secrets, ConfigMaps, and TokenReviews can contain sensitive \u0026 binary data, # so only log at the Metadata level. - level: Metadata resources: - group: \"\" # core resources: [\"secrets\", \"configmaps\"] - group: authentication.k8s.io resources: [\"tokenreviews\"] omitStages: - \"RequestReceived\" # Get repsonses can be large; skip them. - level: Request verbs: [\"get\", \"list\", \"watch\"] resources: ${known_apis} omitStages: - \"RequestReceived\" # Default level for known APIs - level: RequestResponse resources: ${known_apis} omitStages: - \"RequestReceived\" # Default level for all other requests. - level: Metadata omitStages: - \"RequestReceived\" Note also that the Audit Policy stands in the audit.k8s.io API group and the current version is v1.\nAudit Backend Audit backends persist audit events to an external storage. Kube-apiserver out of the box provides three backends:\n Log backend, which writes audit events to a file in JSON format; Webhook backend, which sends audit events to a remote API, which is assumed to be the same API as kube-apiserver exposes; Dynamic backend, which configures webhook backends through an AuditSink API object.  Both logging and webhook backend support batching (enabled by default in webhook and disabled in log), for example to buffer events and asynchronously process them (In this case take tuning into account); they support also truncation.\nOther Kubernetes components Generally, the kubelet and container runtime write logs to journald, on machines with systemd. If systemd is not present, they write to .log files in the /var/log directory. System components inside containers like the kube-scheduler and the kube-proxy always write to the /var/log directory, bypassing the default logging mechanism.\nUnderline components Once covered the high level of the stack is important to audit also the underline components, from the container logs to the syscalls.\nContainer logs Generally speaking, in order to decouple at scale the logging system from the application a standard interface to log streams should be used, and what’s more standard of the standard streams?\nI recommended writing container logs to stdout and stderr also because is handled and redirected somewhere by the container engine. For example, the Docker container engine redirects those two streams to a logging driver, which is configured in Kubernetes to write to a file in json form.\nSyscalls Instead, speaking of system calls Falco can detect and alert on any behavior that involves making Linux system calls. For example, you can easily detect when:\n A shell is run inside a container A server process spawns a child process of an unexpected type A sensitive file, like /etc/shadow, is unexpectedly read A non-device file is written to /dev A standard system binary (like ls) makes an outbound network connection  Falco is deployed as a long-running daemon and is configured via a general configuration file and a rules file that is meant to be tailored to needs. Here you can see example rules that can detect anomalous events.\nWhen Falco detects suspicious behavior, it sends alerts via one or more channels:\n Writing to standard error Writing to a file Writing to syslog Pipe to a spawned program. A common use of this output type would be to send an email for every Falco notification.  One difference between Falco and other tools is that Falco runs in userspace, using a kernel module and eBPF probes to obtain system calls and bring them to userspace, while the other tools perform system call filtering/monitoring at the kernel level; thanks to that it can have a much richer set of information powering its policies.\nBeyond system calls Falco’s event sources can be also Kubernetes Events that are filtered through these rules. For this purpose, it exposes a webhook endpoint that can be used as a Kubernetes Audit webhook backend.\nIn order to install and configure it please refer to the official docs.\nLogs management As for all logs, it is important to collect them and possibly ship them to a centralized and secured log store, available for further process.\nDifferent shipping and collecting tools can be leveraged, such as fluentd and logstash. We’ll not deepen about it here for conciseness.\nConclusion This post is not intended to provide the truth, instead to provide insights from my point of view. I purposely did not cover the auditing implementations of the cloud providers, to shift the focus on the fundamentals.\nI hope it was interesting for you, if you liked it please let me know, if you don’t agree please let me know, I appreciate sharing opinions and I always aim to learn something new and from different points of view!\nFor this post that’s all, happy hacking!\n","wordCount":"1422","inLanguage":"en","datePublished":"2020-02-23T18:36:15+02:00","dateModified":"2020-02-23T18:36:15+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://maxgio92.github.io/posts/k8s-stride-03-repudiation/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"http://maxgio92.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=http://maxgio92.github.io/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://maxgio92.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=http://maxgio92.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://maxgio92.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</h1><div class=post-meta><span title="2020-02-23 18:36:15 +0200 +0200">February 23, 2020</span></div></header><div class=post-content><p>Hi all, this is the third part of this little series about STRIDE threat modeling on Kubernetes. Previously we talked about Tampering; today we talk about <strong>Repudiation</strong>.</p><p>Repudiation is the ability to cast doubt on something that happened. What typically happens is that the attacker aims to deny the authorship of his actions.</p><p>Generally the opposite and thus the desired goal is prooving:</p><ul><li>What</li><li>When</li><li>Where</li><li>Why</li><li>Who</li><li>How</li></ul><p>on certain actions. Non-repudiation refers to a situation where a statement&rsquo;s author cannot successfully dispute its authorship and involves associating actions or changes with a unique individual.</p><p>So, we can mitigate the risks by enabling auditing on the Kubernetes components and gain visibility on actions performed by individual users, administrators or components of the system.</p><p>Let&rsquo;s split out the components into two categories:</p><ul><li>Kubernetes components</li><li>Underline components</li></ul><h1 id=kubernetes-components>Kubernetes components<a hidden class=anchor aria-hidden=true href=#kubernetes-components>#</a></h1><h2 id=api-server>API Server<a hidden class=anchor aria-hidden=true href=#api-server>#</a></h2><p>As the focal point to the API and the front end of the control plane, kube-apiserver performs auditing on the requests and for each of them, it generates an event.</p><p>Each event is then pre-processed according to a policy and then written to a backend.</p><p>The policy determines what&rsquo;s recorded and the backend persists the records, which can be log files or webhooks.</p><p>Each request can be recorded with an associated stage, which are:</p><ul><li><code>RequestReceived</code> - The stage for events generated as soon as the audit handler receives the request, and before it is delegated down the handler chain.</li><li><code>ResponseStarted</code> - Once the response headers are sent, but before the response body is sent. This stage is only generated for long-running requests (e.g. watch).</li><li><code>ResponseComplete</code> - The response body has been completed and no more bytes will be sent.
Panic - Events generated when a panic occurred.</li></ul><h3 id=audit-policy>Audit Policy<a hidden class=anchor aria-hidden=true href=#audit-policy>#</a></h3><p>When an event is processed, it&rsquo;s compared against the list of rules of the Audit Policy in order. The first matching rule sets the audit level of the event.</p><p>In order to enable a policy, you can pass the policy file to the kube-apiserver command using the - <code>audit-policy-file</code> flag.</p><p>Is important to note that configuring a correct policy is crucial, so when configuring your own audit policy is recommended to refer to the GCE policy:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>audit.k8s.io/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Policy</span>
<span style=color:#f92672>rules</span>:
  <span style=color:#75715e># The following requests were manually identified as high-volume and low-risk,</span>
  <span style=color:#75715e># so drop them.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:kube-proxy&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;watch&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;endpoints&#34;</span>, <span style=color:#e6db74>&#34;services&#34;</span>, <span style=color:#e6db74>&#34;services/status&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#75715e># Ingress controller reads &#39;configmaps/ingress-uid&#39; through the unsecured port.</span>
    <span style=color:#75715e># TODO(#46983): Change this to the ingress controller service account.</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:unsecured&#34;</span>]
    <span style=color:#f92672>namespaces</span>: [<span style=color:#e6db74>&#34;kube-system&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;configmaps&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;kubelet&#34;</span>] <span style=color:#75715e># legacy kubelet identity</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes&#34;</span>, <span style=color:#e6db74>&#34;nodes/status&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>userGroups</span>: [<span style=color:#e6db74>&#34;system:nodes&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes&#34;</span>, <span style=color:#e6db74>&#34;nodes/status&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>:
      - <span style=color:#ae81ff>system:kube-controller-manager</span>
      - <span style=color:#ae81ff>system:kube-scheduler</span>
      - <span style=color:#ae81ff>system:serviceaccount:kube-system:endpoint-controller</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;update&#34;</span>]
    <span style=color:#f92672>namespaces</span>: [<span style=color:#e6db74>&#34;kube-system&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;endpoints&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:apiserver&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;namespaces&#34;</span>, <span style=color:#e6db74>&#34;namespaces/status&#34;</span>, <span style=color:#e6db74>&#34;namespaces/finalize&#34;</span>]
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;cluster-autoscaler&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;update&#34;</span>]
    <span style=color:#f92672>namespaces</span>: [<span style=color:#e6db74>&#34;kube-system&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;configmaps&#34;</span>, <span style=color:#e6db74>&#34;endpoints&#34;</span>]
  <span style=color:#75715e># Don&#39;t log HPA fetching metrics.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>users</span>:
      - <span style=color:#ae81ff>system:kube-controller-manager</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;metrics.k8s.io&#34;</span>
  <span style=color:#75715e># Don&#39;t log these read-only URLs.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>nonResourceURLs</span>:
      - <span style=color:#ae81ff>/healthz*</span>
      - <span style=color:#ae81ff>/version</span>
      - <span style=color:#ae81ff>/swagger*</span>
  <span style=color:#75715e># Don&#39;t log events requests.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>None</span>
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;events&#34;</span>]
  <span style=color:#75715e># node and pod status calls from nodes are high-volume and can be large, don&#39;t log responses for expected updates from nodes</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;kubelet&#34;</span>, <span style=color:#e6db74>&#34;system:node-problem-detector&#34;</span>, <span style=color:#e6db74>&#34;system:serviceaccount:kube-system:node-problem-detector&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;update&#34;</span>,<span style=color:#e6db74>&#34;patch&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes/status&#34;</span>, <span style=color:#e6db74>&#34;pods/status&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>userGroups</span>: [<span style=color:#e6db74>&#34;system:nodes&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;update&#34;</span>,<span style=color:#e6db74>&#34;patch&#34;</span>]
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;nodes/status&#34;</span>, <span style=color:#e6db74>&#34;pods/status&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># deletecollection calls can be large, don&#39;t log responses for expected namespace deletions</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>users</span>: [<span style=color:#e6db74>&#34;system:serviceaccount:kube-system:namespace-controller&#34;</span>]
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;deletecollection&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Secrets, ConfigMaps, and TokenReviews can contain sensitive &amp; binary data,</span>
  <span style=color:#75715e># so only log at the Metadata level.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Metadata</span>
    <span style=color:#f92672>resources</span>:
      - <span style=color:#f92672>group</span>: <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># core</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;secrets&#34;</span>, <span style=color:#e6db74>&#34;configmaps&#34;</span>]
      - <span style=color:#f92672>group</span>: <span style=color:#ae81ff>authentication.k8s.io</span>
        <span style=color:#f92672>resources</span>: [<span style=color:#e6db74>&#34;tokenreviews&#34;</span>]
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Get repsonses can be large; skip them.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Request</span>
    <span style=color:#f92672>verbs</span>: [<span style=color:#e6db74>&#34;get&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span>, <span style=color:#e6db74>&#34;watch&#34;</span>]
    <span style=color:#f92672>resources</span>: <span style=color:#ae81ff>${known_apis}</span>
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Default level for known APIs</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>RequestResponse</span>
    <span style=color:#f92672>resources</span>: <span style=color:#ae81ff>${known_apis}</span>
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
  <span style=color:#75715e># Default level for all other requests.</span>
  - <span style=color:#f92672>level</span>: <span style=color:#ae81ff>Metadata</span>
    <span style=color:#f92672>omitStages</span>:
      - <span style=color:#e6db74>&#34;RequestReceived&#34;</span>
</code></pre></div><p>Note also that the Audit Policy stands in the <a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/apis/audit/v1/types.go>audit.k8s.io</a> API group and the current version is v1.</p><h3 id=audit-backend>Audit Backend<a hidden class=anchor aria-hidden=true href=#audit-backend>#</a></h3><p>Audit backends persist audit events to an external storage. Kube-apiserver out of the box provides three backends:</p><ul><li><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#log-backend>Log backend</a>, which writes audit events to a file in JSON format;</li><li><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#webhook-backend>Webhook backend</a>, which sends audit events to a remote API, which is assumed to be the same API as kube-apiserver exposes;</li><li><a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#dynamic-backend>Dynamic backend</a>, which configures webhook backends through an AuditSink API object.</li></ul><p>Both logging and webhook backend support <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#batching>batching</a> (enabled by default in webhook and disabled in log), for example to buffer events and asynchronously process them (In this case take <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#parameter-tuning>tuning</a> into account); they support also <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#truncate>truncation</a>.</p><h2 id=other-kubernetes-components>Other Kubernetes components<a hidden class=anchor aria-hidden=true href=#other-kubernetes-components>#</a></h2><p>Generally, the <code>kubelet</code> and container runtime write logs to journald, on machines with systemd. If systemd is not present, they write to .log files in the /var/log directory.
System components inside containers like the kube-scheduler and the kube-proxy always write to the <code>/var/log</code> directory, bypassing the default logging mechanism.</p><h1 id=underline-components>Underline components<a hidden class=anchor aria-hidden=true href=#underline-components>#</a></h1><p>Once covered the high level of the stack is important to audit also the underline components, from the container logs to the syscalls.</p><h2 id=container-logs>Container logs<a hidden class=anchor aria-hidden=true href=#container-logs>#</a></h2><p>Generally speaking, in order to decouple at scale the logging system from the application a standard interface to log streams should be used, and what&rsquo;s more standard of the standard streams?</p><p>I recommended writing container logs to stdout and stderr also because is handled and redirected somewhere by the container engine. For example, the Docker container engine redirects those two streams to a logging driver, which is configured in Kubernetes to write to a file in json form.</p><h2 id=syscalls>Syscalls<a hidden class=anchor aria-hidden=true href=#syscalls>#</a></h2><p>Instead, speaking of system calls <a href=https://falco.org>Falco</a> can detect and alert on any behavior that involves making Linux system calls. For example, you can easily detect when:</p><ul><li>A shell is run inside a container</li><li>A server process spawns a child process of an unexpected type</li><li>A sensitive file, like /etc/shadow, is unexpectedly read</li><li>A non-device file is written to /dev</li><li>A standard system binary (like ls) makes an outbound network connection</li></ul><p>Falco is deployed as a long-running daemon and is configured via a general <a href=https://falco.org/docs/configuration/>configuration file</a> and a <a href=https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml>rules file</a> that is meant to be tailored to needs. <a href=https://falco.org/docs/examples/>Here</a> you can see example rules that can detect anomalous events.</p><p>When Falco detects suspicious behavior, it sends alerts via one or more channels:</p><ul><li>Writing to standard error</li><li>Writing to a file</li><li>Writing to syslog</li><li>Pipe to a spawned program. A common use of this output type would be to send an email for every Falco notification.</li></ul><p>One difference between Falco and other tools is that Falco runs in userspace, using a kernel module and eBPF probes to obtain system calls and bring them to userspace, while the other tools perform system call filtering/monitoring at the kernel level; thanks to that it can have a much richer set of information powering its policies.</p><p>Beyond system calls Falco&rsquo;s event sources can be also Kubernetes Events that are filtered through these rules. For this purpose, it exposes a webhook endpoint that can be used as a Kubernetes Audit webhook backend.</p><p>In order to install and configure it please refer to the official docs.</p><h1 id=logs-management>Logs management<a hidden class=anchor aria-hidden=true href=#logs-management>#</a></h1><p>As for all logs, it is important to collect them and possibly ship them to a centralized and secured log store, available for further process.</p><p>Different shipping and collecting tools can be leveraged, such as <a href=https://www.fluentd.org/>fluentd</a> and <a href=https://www.elastic.co/logstash>logstash</a>. We&rsquo;ll not deepen about it here for conciseness.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>This post is not intended to provide the truth, instead to provide insights from my point of view. I purposely did not cover the auditing implementations of the cloud providers, to shift the focus on the fundamentals.</p><p>I hope it was interesting for you, if you liked it please let me know, if you don&rsquo;t agree please let me know, I appreciate sharing opinions and I always aim to learn something new and from different points of view!</p><p>For this post that&rsquo;s all, happy hacking!</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://maxgio92.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=http://maxgio92.github.io/tags/security/>security</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://maxgio92.github.io/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>