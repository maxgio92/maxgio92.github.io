<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure | Maxgio's blog</title><meta name=keywords content="kubernetes,security"><meta name=description content="This is the fourth part of a series about STRIDE threat modeling in Kubernetes. In the previous part we talked about repudiation, instead today we&rsquo;ll going to address information disclosure.
Information disclosure happens with data leaks or data breaches, whenever a system that is designed to be closed to an eavesdropper unintentionally reveals some information to unauthorized parties.
To prevent this we should protect data in transit and at rest by guaranteeing confidentiality, which can be guaranteed with encryption."><meta name=author content><link rel=canonical href=http://maxgio92.github.io/posts/k8s-stride-04-information-disclosure/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=http://maxgio92.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://maxgio92.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://maxgio92.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://maxgio92.github.io/apple-touch-icon.png><link rel=mask-icon href=http://maxgio92.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure"><meta property="og:description" content="This is the fourth part of a series about STRIDE threat modeling in Kubernetes. In the previous part we talked about repudiation, instead today we&rsquo;ll going to address information disclosure.
Information disclosure happens with data leaks or data breaches, whenever a system that is designed to be closed to an eavesdropper unintentionally reveals some information to unauthorized parties.
To prevent this we should protect data in transit and at rest by guaranteeing confidentiality, which can be guaranteed with encryption."><meta property="og:type" content="article"><meta property="og:url" content="http://maxgio92.github.io/posts/k8s-stride-04-information-disclosure/"><meta property="og:image" content="http://maxgio92.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-23T18:36:15+02:00"><meta property="article:modified_time" content="2020-03-23T18:36:15+02:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://maxgio92.github.io/papermod-cover.png"><meta name=twitter:title content="STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure"><meta name=twitter:description content="This is the fourth part of a series about STRIDE threat modeling in Kubernetes. In the previous part we talked about repudiation, instead today we&rsquo;ll going to address information disclosure.
Information disclosure happens with data leaks or data breaches, whenever a system that is designed to be closed to an eavesdropper unintentionally reveals some information to unauthorized parties.
To prevent this we should protect data in transit and at rest by guaranteeing confidentiality, which can be guaranteed with encryption."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://maxgio92.github.io/posts/"},{"@type":"ListItem","position":2,"name":"STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure","item":"http://maxgio92.github.io/posts/k8s-stride-04-information-disclosure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure","name":"STRIDE threat modeling on Kubernetes pt.4\/6: Information disclosure","description":"This is the fourth part of a series about STRIDE threat modeling in Kubernetes. In the previous part we talked about repudiation, instead today we\u0026rsquo;ll going to address information disclosure.\nInformation disclosure happens with data leaks or data breaches, whenever a system that is designed to be closed to an eavesdropper unintentionally reveals some information to unauthorized parties.\nTo prevent this we should protect data in transit and at rest by guaranteeing confidentiality, which can be guaranteed with encryption.","keywords":["kubernetes","security"],"articleBody":"This is the fourth part of a series about STRIDE threat modeling in Kubernetes. In the previous part we talked about repudiation, instead today we’ll going to address information disclosure.\nInformation disclosure happens with data leaks or data breaches, whenever a system that is designed to be closed to an eavesdropper unintentionally reveals some information to unauthorized parties.\nTo prevent this we should protect data in transit and at rest by guaranteeing confidentiality, which can be guaranteed with encryption.\nMost of the data in Kubernetes is part of his state, the sensitive part of which is represented by Secret API objects, stored in ectd. So, first of all, to prevent information disclosure we should encrypt data, especially secret, at rest and in transit.\nFurthermore, we should consider also data that can be sensitive or at least be used to gain extra privileges in the cluster or in the cloud provider, such as all sensitive data generated by our workload that won’t be stored in Secrets or, for example, cloud metadata from the cloud provider’s API.\nBut let’s go deeper and start from data at rest.\nData at rest As we said, to avoid unwanted parts access sensitive data, we can restrict access to it. At the same time, to avoid that even if that data is unintentionally accessed it can be read, we can encrypt it.\nRestrict access etcd Only the API server and other etcd nodes should be able to access etcd since write access is equivalent to gaining root on the entire cluster, and read access can be used to gain extra privileges.\nYou can enforce restrictions on it with ACL at firewall-level and with strong authentication with PKI and X.509 certificates, which are supported by etcd.\nTwo are the authentication to consider:\n between etcd peers between the API server and etcd.  To secure communications between etcd peers you can use these etcd flags:\n –peer-key-file= –peer-cert-file= –peer-client-cert-auth –peer-trusted-ca-file=  To secure communication between the API server and etcd use these ones:\n –cert-file= –key-file= –client-cert-auth –trusted-ca-file=  and at the same time configure the API server with these flags:\n –etcd-certfile= –etcd-keyfile=  Note: in this case in order to allow API server to communicate with etcd the certificate client.crt should be trusted by the CA with certificate etcd-ca.crt. Here you can find scripts to setup certs and key pairs for these individuals communications.\nConsider all of that for learning purposes because if you - or your provider - set up the cluster with kubeadm, it manages all of that by built-in and you likely won’t need to setup PKI for etcd and API server by yourself, except only for advanced cases.\nAnyway, we’ll talk about PKI management with kubeadm later.\nSecret API When deploying applications that interact with the Secret API, you should limit access using RBAC policies.\nConsider that Secrets can also be used to gain extra privileges, as for service account tokens. For example, components that create pods inside system namespaces like kube-system can be unexpectedly powerful because those pods can gain access to service account secrets or run with elevated permissions if those service accounts are granted access to permissive PSPs.\nFor this reason always review permissions that components need: generally watch and list requests for secrets within a namespace should be avoided since listing Secrets allows the clients to inspect the values of all Secrets that are in that namespace. The permission to watch and list all Secrets in a cluster should be reserved only to trusted system components. To let applications access the Secret objects it should be allowed only get requests on the needed Secrets, in order to apply the least privilege principle and denying by default.\nFurthermore, consider that if a user can create a Pod that uses a Secret, he could expose the Secret even if the API server policy does not allow that user to read the Secret.\nAnother method to access the Secret API objects can be by impersonating the kubelet because it can be read any Secret from the API server. You can prevent this by enforcing authentication and authorization restrictions on the kubelet binary, on the RBAC permissions, but in this case, you should migrate to manage the authorization on kubelets with Node Authorization and enabling the Node restriction admission controller.\nIn addition, review the RBAC permissions of the objects that access the kubelet.\nSecret Volumes A Secret is sent to a node only if a Pod on that node requires it and the kubelet stores the Secret into a tmpfs so that the Secret is not written to disk storage. Once the Pod that depends on the Secret is deleted, the kubelet will delete its local copy of the secret data as well.\nFurthermore, only the Secrets that a pod requests are potentially visible within its containers. Therefore, one Pod does not have access to the Secrets of another Pod. And each container in a Pod has to request the Secret volume in its volumeMounts for it to be visible within the container.\nSo, the prevention can be made by design, by separating the responsibilities and by not exposing services that have access to Secrets as much as possible.\nYou can enforce Secret access control from Pods with external secret managers like Vault that from December 2019 supports Secret injection with vault-k8s, which is a Kubernetes mutating admission control webhook that alters pod spec to include Vault Agent containers that render Vault secrets to a shared memory volume, so that containers within the pod only need to read filesystem data without being aware of Vault.\nHere you can read their blog post about it.\nCloud metadata API In addition to data restrictively stored in Kubernetes, cloud providers often expose metadata services locally to instances. By default, these APIs are accessible by pods running on an instance and can contain cloud credentials for that node, or provisioning data such as kubelet credentials. These credentials can be used to escalate within the cluster or to other cloud services under the same account.\nWhen running Kubernetes on a cloud platform limit permissions are given to instance identities (for example fine-tuning IAM instance roles in AWS), use Kubernetes Network Policies to restrict pod access to the metadata API, and avoid using provisioning data to deliver secrets.\nEncrypt etcd You can encrypt data stored in etcd by enable Kubernetes encryption at rest feature, that is available in beta version from version 1.13, so that the Secrets are not stored in plaintext into etcd, and even if an attacker can gain access to it, he can’t read it; so let’s see briefly how it works.\nThe API server binary accepts an argument - encryption-provider-config to pass an encryption configuration that controls how data is encrypted in etcd. The configuration is an API object that is part of the apiserver.config.k8s.io API group, as you can see in the example below:\napiVersion:apiserver.config.k8s.io/v1kind:EncryptionConfigurationresources:- resources:- secretsproviders:- aescbc:keys:- name:key1secret:- identity:{}As you can see each resources array item is a separate complete configuration; the resources.resources field is an array of resource names (i.e. secrets) that should be encrypted.\nThe providers array is an ordered list of the possible encryption providers which currently are:\n identity aescbc secretbox aesgcm kms  Important: note that as the first provider specified in the list is used to encrypt resources, and since the identity provider is used by default which provides no encryption, if you place it as the first item you disable encryption.\nFurthermore, since the config file can contain keys that can decrypt content in etcd, you should restrict permissions on your master nodes so only the user who runs the API server can read it.\nA better approach is envelope encryption where it’s generated a data encryption key that encrypts the data, and then the data encryption key is encrypted with a key encryption key to protect it. It could be encrypted also the KEK but eventually, one key must be in plaintext in order to decrypt the keys and finally the data. The top-level key is the master key and it should be stored outside of the cluster.\nDoing so, you don’t have to worry about storing the encrypted data key, because it is protected by encryption; furthermore, since the data could be large, you gain in performance as you don’t have to re-encrypt multiple times the same data with different keys, but you can re-encrypt only the data keys that protects the data.\nThe KMS encryption provider uses envelope encryption to encrypt data in etcd and the master/key encryption key is stored and managed in a remote KMS, letting the user be able to rotate it. The KMS provider uses gRPC to communicate with a specific KMS plugin; the KMS plugin, which is implemented as a gRPC server, communicates with the remote KMS.\nNote that if you are using EKS they just introduced the support for envelope encryption of Secrets with KMS a little time ago; here the announcement.\nOther than etcd, you can prevent from reading secret data by encrypting your backups as well as full disks; for example, if your cluster runs in AWS on EC2 instances you can enable encryption of EBS volumes, or if you use EKS for example is provided by default.\nVCS If you configure secret data in general (Secrets objects, inputs for Kustomize secret generators, chart values, etc.) through a manifest which has the secret data encoded as base64 and you choose to put under git versioning that data, it means the secret is compromised becase Base64 encoding is not an encryption method and it will be the same as plain text.\nYou can protect that versioned secret by encrypting it using tools like git-crypt or even better SOPS, which integrates very well with most cloud provider’s KMS, other than PGP.\nYou can reach a level of granularity where you use an AWS KMS Customer Master Key and a least-privilege AWS IAM role both dedicated only to a single file inside a repository, to encrypt and decrypt… that’s amazing! If you are interested and you don’t already know it, this introductive video is recommended.\nFurthermore, as Helm is the de-facto standard for package management and you likely want to version chart configurations, in case these contain secret data you likely also want to protect them. Even here you can leverage SOPS by using the helm-secrets Helm plugin. Logs\nA little additional point: even if all the above measures taken place, be sure to not accidentally expose secret data read from volumes or environment by writing it to logs or shipping it to external services, for example data collectors.\nData in transit Encrypt Other than the data at rest is important to encrypt in-transit data. TLS provides a protocol to manage encryption of the data in communications between two parties.\nIt defines how they agree on the cipher suite, that is a set of algorithms to secure the connection, which usually contains the algorithm used to exchange the encryption key, the encryption algorithm itself, the message authentication code (MAC) algorithm for integrity check, and optionally an authentication algorithm. TLS itself decides which are the required features of supported cipher suites (for example in TLS 1.3, many legacy algorithms have been dropped).\nAuthentication in TLS is an optional feature but is highly recommended, and by default using the security features of etcd you protect in-transit data with encryption via TLS and restrict the communication to only trusted peers with a Public Key Infrastructure and X.509 certificates.\nIn the Kubernetes world in order to protect the communications you must consider data transmitted between and to Kubernetes components and between application components.\nBetween/to Kubernetes components On most Kubernetes distributions, communication between master and worker components, is protected by TLS. Specifically the same applies between etcd nodes, and between API server and etcd as explained above.\nIn this way data and specifically sensitive data in transit is protected when transmitted over these channels.\nIf you install Kubernetes with kubeadm, the certificates that your cluster requires are automatically generated and placed under /etc/kubernetes/pki. Consider that Kubernetes requires PKI for the following operations:\n Client certificates for the kubelet + kubeconfig to authenticate to the API server Server certificate for the API server endpoint Client certificates + kubeconfig for administrators of the cluster to authenticate to the API server Client certificates for the API server to talk to the kubelets Client certificate for the API server to talk to etcd Client certificate + kubeconfig for the controller manager to talk to the API server Client certificate + kubeconfig for the scheduler to talk to the API server Client and server certificates for etcd to authenticate between themselves  If you run kube-proxy to support an extension API Server, client and server certificates for the front-proxy\nIn case you don’t want to let kubeadm to create these certificates for example because you need to integrate your certificate infrastructure into a kubeadm-built cluster you can either create and inject intermediate CAs from your root CA to let kubeadm to create the certificates or, in case you don’t want to copy your CAs into the cluster you can create all the certificates by yourself. Anyway proceed only if you know what are you doing and consider that in most cases the default kubeadm configuration is fine.\nFor the control plane, the certificates are valid for one year and kubeadm renews them by default during the control plane upgrade. If this configuration does not fit your need you can disable renewal during upgrade by passing - certificate-renewal=false option to kubeadm upgrade apply or to kubeadm upgrade node.\nThen, you can even manage the renewals manually via the Kubernetes Certificates API by signing the certificates with the controller manager’s built-in signer or by using systems like cert-manager; furthermore, you can also renew certificates with your external CA and let kubeadm create only your CSRs.\nInstead, the certificate and kubeconfig of the kubelet are automatically updated by themselves; take a look here also for automatic certificates bootstrapping of the kubelets for communications to the API server, needed for example when scaling up the worker nodes.\nBy the way, you likely won’t need to do a lot of work to secure communications between Kubernetes components, as kubeadm manages most of the parts of the PKI; moreover, if a cloud provider hosts your cluster it probably also offers additional operational features.\nBetween application components For components that you develop and deploy, consider to encrypt the communications with mTLS to provide mutual authentication between them, by leveraging service meshes like Istio or Linkerd, where other than encryption you guarantee that both components are trusting each other and they manage entirely the PKI for your mesh.\nYou could also setup and manage PKI by yourself by using certificate managers like cert-manager that works with external CAs, for example,b provided by Vault (yes, it can also be used as a root/intermediate CA). Anyway, it’s not a good idea since it can be complex, especially in situations where you have microservices… you would freak out.\nA service mesh framework provides also a lot of features; on the security perspective, it can covers also authorization and audit, other than authentication (and encryption), as Istio does with secure naming that maps server identities encoded in certificates with service names and checks against policies, to control if an identity is authorized to run a service.\nBut that is only a part of the security aspects that a service mesh covers; it can manage load balancing, access control, observability, canary releasing, etc. They can cover also the authentication from the end-user, other than in communications between services, for example by supporting OpenID Connect providers. In addition to the encryption of the whole communication, you can and should also encrypt specific sensitive data by leveraging secrets manager like Vault; it also provides encryption as a service thanks to its transit secrets engine.\nYou can use Vault to generate and manage tokens, which in turn - as said before - can be injected runtime into your workload without being aware of the secrets manager.\nFinally, if you’d deploy third-party components consider that Kubernetes expects that all API communication in the cluster is encrypted by default with TLS, and the majority of installation methods will allow the necessary certificates to be created and distributed to the cluster components.\nAnyway some components and installation methods may enable local ports over HTTP, so you should check every setting to identify potentially unsecured traffic and, if supported, enable TLS encryption and if not, look for alternative components that will do.\nConclusion “The power of a system comes more from the relationships among programs than from the programs themselves” (The UNIX Programming Environment). As the UNIX way probably shaped the Kubernetes architecture the relationships are to be carefully managed and secured as like as the data that transits in and be generated by.\nWhereas this, this part covered a lot of aspects and because of that it has been hard to put practice demos; anyway I tried to provide as much references as I can to let you deepen by yourself the topics you’re most interested in.\nThat’s all folks! I hope you liked this part and to I hope to see you later in the next part about Denial of service.\nHappy hacking!\n","wordCount":"2880","inLanguage":"en","datePublished":"2020-03-23T18:36:15+02:00","dateModified":"2020-03-23T18:36:15+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://maxgio92.github.io/posts/k8s-stride-04-information-disclosure/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"http://maxgio92.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=http://maxgio92.github.io/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://maxgio92.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=http://maxgio92.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://maxgio92.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/maxgio92 title=Github><span>Github</span></a></li><li><a href=https://twitter/maxgio92 title=Twitter><span>Twitter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://maxgio92.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://maxgio92.github.io/posts/>Posts</a></div><h1 class=post-title>STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure</h1><div class=post-meta><span title="2020-03-23 18:36:15 +0200 +0200">March 23, 2020</span>&nbsp;·&nbsp;14 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#data-atrest aria-label="Data at rest">Data at rest</a><ul><li><a href=#restrict-access aria-label="Restrict access">Restrict access</a><ul><li><a href=#etcd aria-label=etcd>etcd</a></li><li><a href=#secret-api aria-label="Secret API">Secret API</a></li><li><a href=#secret-volumes aria-label="Secret Volumes">Secret Volumes</a></li><li><a href=#cloud-metadata-api aria-label="Cloud metadata API">Cloud metadata API</a></li></ul></li><li><a href=#encrypt aria-label=Encrypt>Encrypt</a><ul><li><a href=#etcd-1 aria-label=etcd>etcd</a></li><li><a href=#vcs aria-label=VCS>VCS</a></li></ul></li></ul></li><li><a href=#data-intransit aria-label="Data in transit">Data in transit</a><ul><li><a href=#encrypt-1 aria-label=Encrypt>Encrypt</a><ul><li><a href=#betweento-kubernetes-components aria-label="Between/to Kubernetes components">Between/to Kubernetes components</a></li><li><a href=#between-application-components aria-label="Between application components">Between application components</a></li></ul></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>This is the fourth part of a series about STRIDE threat modeling in Kubernetes. In the previous part we talked about repudiation, instead today we&rsquo;ll going to address <strong>information disclosure</strong>.</p><p>Information disclosure happens with data leaks or data breaches, whenever a system that is designed to be closed to an eavesdropper unintentionally reveals some information to unauthorized parties.</p><p>To prevent this we should protect data in transit and at rest by guaranteeing confidentiality, which can be guaranteed with encryption.</p><p>Most of the data in Kubernetes is part of his state, the sensitive part of which is represented by Secret API objects, stored in ectd. So, first of all, to prevent information disclosure we should encrypt data, especially secret, at rest and in transit.</p><p>Furthermore, we should consider also data that can be sensitive or at least be used to gain extra privileges in the cluster or in the cloud provider, such as all sensitive data generated by our workload that won&rsquo;t be stored in Secrets or, for example, cloud metadata from the cloud provider&rsquo;s API.</p><p>But let&rsquo;s go deeper and start from data at rest.</p><h1 id=data-atrest>Data at rest<a hidden class=anchor aria-hidden=true href=#data-atrest>#</a></h1><p>As we said, to avoid unwanted parts access sensitive data, we can restrict access to it. At the same time, to avoid that even if that data is unintentionally accessed it can be read, we can encrypt it.</p><h2 id=restrict-access>Restrict access<a hidden class=anchor aria-hidden=true href=#restrict-access>#</a></h2><h3 id=etcd>etcd<a hidden class=anchor aria-hidden=true href=#etcd>#</a></h3><p>Only the API server and other etcd nodes should be able to access etcd since write access is equivalent to gaining root on the entire cluster, and read access can be used to gain extra privileges.</p><p>You can enforce restrictions on it with ACL at firewall-level and with strong authentication with PKI and X.509 certificates, which are supported by etcd.</p><p>Two are the authentication to consider:</p><ul><li>between etcd peers</li><li>between the API server and etcd.</li></ul><p>To secure communications between etcd peers you can use these etcd flags:</p><ul><li>–peer-key-file=&lt;peer.key></li><li>–peer-cert-file=&lt;peer.cert></li><li>–peer-client-cert-auth</li><li>–peer-trusted-ca-file=&lt;etcd-ca.cert></li></ul><p>To secure communication between the API server and etcd use these ones:</p><ul><li>–cert-file=&lt;server.crt></li><li>–key-file=&lt;server.key></li><li>–client-cert-auth</li><li>–trusted-ca-file=&lt;etcd-ca.crt></li></ul><p>and at the same time configure the API server with these flags:</p><ul><li>–etcd-certfile=&lt;client.crt></li><li>–etcd-keyfile=&lt;client.key></li></ul><p>Note: in this case in order to allow API server to communicate with etcd the certificate client.crt should be trusted by the CA with certificate etcd-ca.crt.
<a href=https://github.com/etcd-io/etcd/tree/main/hack/tls-setup>Here</a> you can find scripts to setup certs and key pairs for these individuals communications.</p><p>Consider all of that for learning purposes because if you - or your provider - set up the cluster with kubeadm, it manages all of that by built-in and you likely won&rsquo;t need to setup PKI for etcd and API server by yourself, except only for advanced cases.</p><p>Anyway, we&rsquo;ll talk about PKI management with kubeadm later.</p><h3 id=secret-api>Secret API<a hidden class=anchor aria-hidden=true href=#secret-api>#</a></h3><p>When deploying applications that interact with the Secret API, you should limit access using RBAC policies.</p><p>Consider that Secrets can also be used to gain extra privileges, as for service account tokens. For example, components that create pods inside system namespaces like kube-system can be unexpectedly powerful because those pods can gain access to service account secrets or run with elevated permissions if those service accounts are granted access to permissive PSPs.</p><p>For this reason always review permissions that components need: generally watch and list requests for secrets within a namespace should be avoided since listing Secrets allows the clients to inspect the values of all Secrets that are in that namespace. The permission to watch and list all Secrets in a cluster should be reserved only to trusted system components.
To let applications access the Secret objects it should be allowed only get requests on the needed Secrets, in order to apply the least privilege principle and denying by default.</p><p>Furthermore, consider that if a user can create a Pod that uses a Secret, he could expose the Secret even if the API server policy does not allow that user to read the Secret.</p><p>Another method to access the Secret API objects can be by impersonating the kubelet because it can be read any Secret from the API server.
You can prevent this by enforcing authentication and authorization restrictions on the kubelet binary, on the RBAC permissions, but in this case, you should migrate to manage the authorization on kubelets with Node Authorization and enabling the Node restriction admission controller.</p><p>In addition, review the RBAC permissions of the objects that access the kubelet.</p><h3 id=secret-volumes>Secret Volumes<a hidden class=anchor aria-hidden=true href=#secret-volumes>#</a></h3><p>A Secret is sent to a node only if a Pod on that node requires it and the kubelet stores the Secret into a tmpfs so that the Secret is not written to disk storage. Once the Pod that depends on the Secret is deleted, the kubelet will delete its local copy of the secret data as well.</p><p>Furthermore, only the Secrets that a pod requests are potentially visible within its containers. Therefore, one Pod does not have access to the Secrets of another Pod. And each container in a Pod has to request the Secret volume in its volumeMounts for it to be visible within the container.</p><p>So, the prevention can be made by design, by separating the responsibilities and by not exposing services that have access to Secrets as much as possible.</p><p>You can enforce Secret access control from Pods with external secret managers like <a href=https://www.vaultproject.io/>Vault</a> that from December 2019 supports Secret injection with <a href=https://learn.hashicorp.com/vault/identity-access-management/vault-agent-k8s>vault-k8s</a>, which is a Kubernetes mutating admission control webhook that alters pod spec to include Vault Agent containers that render Vault secrets to a shared memory volume, so that containers within the pod only need to read filesystem data without being aware of Vault.</p><p><a href=https://www.hashicorp.com/blog/injecting-vault-secrets-into-kubernetes-pods-via-a-sidecar>Here</a> you can read their blog post about it.</p><h3 id=cloud-metadata-api>Cloud metadata API<a hidden class=anchor aria-hidden=true href=#cloud-metadata-api>#</a></h3><p>In addition to data restrictively stored in Kubernetes, cloud providers often expose metadata services locally to instances. By default, these APIs are accessible by pods running on an instance and can contain cloud credentials for that node, or provisioning data such as kubelet credentials. These credentials can be used to escalate within the cluster or to other cloud services under the same account.</p><p>When running Kubernetes on a cloud platform <a href=https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/#restricting-cloud-metadata-api-access>limit permissions</a> are given to instance identities (for example fine-tuning IAM instance roles in AWS), use Kubernetes <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>Network Policies</a> to restrict pod access to the metadata API, and avoid using provisioning data to deliver secrets.</p><h2 id=encrypt>Encrypt<a hidden class=anchor aria-hidden=true href=#encrypt>#</a></h2><h3 id=etcd-1>etcd<a hidden class=anchor aria-hidden=true href=#etcd-1>#</a></h3><p>You can encrypt data stored in etcd by enable Kubernetes <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>encryption at rest</a> feature, that is available in beta version from version 1.13, so that the Secrets are not stored in plaintext into <a href=https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/>etcd</a>, and even if an attacker can gain access to it, he can&rsquo;t read it; so let&rsquo;s see briefly how it works.</p><p>The API server binary accepts an argument - encryption-provider-config to pass an encryption configuration that controls how data is encrypted in etcd. The configuration is an API object that is part of the <code>apiserver.config.k8s.io</code> API group, as you can see in the example below:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apiserver.config.k8s.io/v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>EncryptionConfiguration</span><span class=w>
</span><span class=w></span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=nt>resources</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=l>secrets</span><span class=w>
</span><span class=w>    </span><span class=nt>providers</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>aescbc</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>keys</span><span class=p>:</span><span class=w>
</span><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>key1</span><span class=w>
</span><span class=w>          </span><span class=nt>secret</span><span class=p>:</span><span class=w> </span><span class=l>&lt;BASE 64 ENCODED SECRET&gt;</span><span class=w>
</span><span class=w>    </span>- <span class=nt>identity</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></code></pre></div><p>As you can see each resources array item is a separate complete configuration; the resources.resources field is an array of resource names (i.e. secrets) that should be encrypted.</p><p>The <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/#providers>providers</a> array is an ordered list of the possible encryption providers which currently are:</p><ul><li>identity</li><li>aescbc</li><li>secretbox</li><li>aesgcm</li><li>kms</li></ul><p><strong>Important</strong>: note that as the first provider specified in the list is used to encrypt resources, and since the identity provider is used by default which provides no encryption, if you place it as the first item you disable encryption.</p><p>Furthermore, since the config file can contain keys that can decrypt content in etcd, you should restrict permissions on your master nodes so only the user who runs the API server can read it.</p><p>A better approach is envelope encryption where it&rsquo;s generated a data encryption key that encrypts the data, and then the data encryption key is encrypted with a key encryption key to protect it.
It could be encrypted also the KEK but eventually, one key must be in plaintext in order to decrypt the keys and finally the data.
The top-level key is the master key and it should be stored outside of the cluster.</p><p>Doing so, you don&rsquo;t have to worry about storing the encrypted data key, because it is protected by encryption; furthermore, since the data could be large, you gain in performance as you don&rsquo;t have to re-encrypt multiple times the same data with different keys, but you can re-encrypt only the data keys that protects the data.</p><p>The <a href=https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/>KMS encryption provider</a> uses envelope encryption to encrypt data in etcd and the master/key encryption key is stored and managed in a remote KMS, letting the user be able to rotate it. The KMS provider uses gRPC to communicate with a specific KMS plugin; the KMS plugin, which is implemented as a gRPC server, communicates with the remote KMS.</p><p>Note that if you are using EKS they just introduced the support for envelope encryption of Secrets with KMS a little time ago; <a href=https://aws.amazon.com/it/about-aws/whats-new/2020/03/amazon-eks-adds-envelope-encryption-for-secrets-with-aws-kms/>here</a> the announcement.</p><p>Other than etcd, you can prevent from reading secret data by encrypting your backups as well as full disks; for example, if your cluster runs in AWS on EC2 instances you can enable encryption of EBS volumes, or if you use EKS for example is provided by default.</p><h3 id=vcs>VCS<a hidden class=anchor aria-hidden=true href=#vcs>#</a></h3><p>If you configure secret data in general (Secrets objects, inputs for <a href=https://kustomize.io>Kustomize</a> <a href=https://github.com/kubernetes-sigs/kustomize/blob/master/examples/secretGeneratorPlugin.md>secret generators</a>, chart values, etc.) through a manifest which has the secret data encoded as base64 and you choose to put under git versioning that data, it means the secret is compromised becase Base64 encoding is not an encryption method and it will be the same as plain text.</p><p>You can protect that versioned secret by encrypting it using tools like git-crypt or even better <a href=https://github.com/mozilla/sops>SOPS</a>, which integrates very well with most cloud provider&rsquo;s KMS, other than PGP.</p><p>You can reach a level of granularity where you use an AWS KMS Customer Master Key and a least-privilege AWS IAM role both dedicated only to a single file inside a repository, to encrypt and decrypt… that&rsquo;s amazing! If you are interested and you don&rsquo;t already know it, this introductive <a href="https://www.youtube.com/watch?v=V2PRhxphH2w">video</a> is recommended.</p><p>Furthermore, as Helm is the de-facto standard for package management and you likely want to version chart configurations, in case these contain secret data you likely also want to protect them. Even here you can leverage SOPS by using the <a href=https://github.com/zendesk/helm-secrets>helm-secrets</a> Helm plugin.
Logs</p><p>A little additional point: even if all the above measures taken place, be sure to not accidentally expose secret data read from volumes or environment by writing it to logs or shipping it to external services, for example data collectors.</p><h1 id=data-intransit>Data in transit<a hidden class=anchor aria-hidden=true href=#data-intransit>#</a></h1><h2 id=encrypt-1>Encrypt<a hidden class=anchor aria-hidden=true href=#encrypt-1>#</a></h2><p>Other than the data at rest is important to encrypt in-transit data.
TLS provides a protocol to manage encryption of the data in communications between two parties.</p><p>It defines how they agree on the cipher suite, that is a set of algorithms to secure the connection, which usually contains the algorithm used to exchange the encryption key, the encryption algorithm itself, the message authentication code (MAC) algorithm for integrity check, and optionally an authentication algorithm. TLS itself decides which are the required features of supported cipher suites (for example in TLS 1.3, many legacy algorithms have been dropped).</p><p>Authentication in TLS is an optional feature but is highly recommended, and by default using the security features of etcd you protect in-transit data with encryption via TLS and restrict the communication to only trusted peers with a Public Key Infrastructure and X.509 certificates.</p><p>In the Kubernetes world in order to protect the communications you must consider data transmitted between and to Kubernetes components and between application components.</p><h3 id=betweento-kubernetes-components>Between/to Kubernetes components<a hidden class=anchor aria-hidden=true href=#betweento-kubernetes-components>#</a></h3><p>On most Kubernetes distributions, communication between master and worker components, is protected by TLS. Specifically the same applies between etcd nodes, and between API server and etcd as explained above.</p><p>In this way data and specifically sensitive data in transit is protected when transmitted over these channels.</p><p>If you install Kubernetes with kubeadm, the certificates that your cluster requires are automatically generated and placed under /etc/kubernetes/pki. Consider that Kubernetes requires PKI for the following operations:</p><ul><li>Client certificates for the kubelet + kubeconfig to authenticate to the API server</li><li>Server certificate for the API server endpoint</li><li>Client certificates + kubeconfig for administrators of the cluster to authenticate to the API server</li><li>Client certificates for the API server to talk to the kubelets</li><li>Client certificate for the API server to talk to etcd</li><li>Client certificate + kubeconfig for the controller manager to talk to the API server</li><li>Client certificate + kubeconfig for the scheduler to talk to the API server</li><li>Client and server certificates for etcd to authenticate between themselves</li></ul><p>If you run <code>kube-proxy</code> to support an extension API Server, client and server certificates for the front-proxy</p><p>In case you don&rsquo;t want to let kubeadm to create these certificates for example because you need to integrate your certificate infrastructure into a kubeadm-built cluster you can either create and <a href=https://kubernetes.io/docs/setup/best-practices/certificates/#single-root-ca>inject intermediate CAs</a> from your root CA to let kubeadm to create the certificates or, in case you don&rsquo;t want to copy your CAs into the cluster you can <a href=https://kubernetes.io/docs/setup/best-practices/certificates/#all-certificates>create all the certificates</a> by yourself. Anyway proceed only if you know what are you doing and consider that in most cases the default kubeadm configuration is fine.</p><p>For the control plane, the certificates are valid for one year and kubeadm renews them by default during the control plane upgrade. If this configuration does not fit your need you can disable renewal during upgrade by passing - certificate-renewal=false option to <code>kubeadm upgrade apply</code> or to <code>kubeadm upgrade node</code>.</p><p>Then, you can even manage the renewals manually via the Kubernetes <a href=https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/><code>Certificates</code> API</a> by signing the certificates with the controller manager&rsquo;s built-in signer or by using systems like <a href=https://cert-manager.io>cert-manager</a>; furthermore, you can also renew certificates with your external CA and let kubeadm <a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#renew-certificates-with-external-ca>create only your CSRs</a>.</p><p>Instead, the certificate and <code>kubeconfig</code> of the <code>kubelet</code> are automatically updated by themselves; take a look here also for automatic certificates bootstrapping of the kubelets for communications to the API server, needed for example when scaling up the worker nodes.</p><p>By the way, you likely won&rsquo;t need to do a lot of work to secure communications between Kubernetes components, as kubeadm manages most of the parts of the PKI; moreover, if a cloud provider hosts your cluster it probably also offers additional operational features.</p><h3 id=between-application-components>Between application components<a hidden class=anchor aria-hidden=true href=#between-application-components>#</a></h3><p>For components that you develop and deploy, consider to encrypt the communications with mTLS to provide mutual authentication between them, by leveraging service meshes like <a href=https://istio.io/latest/docs/tasks/security/authentication/mtls-migration/>Istio</a> or <a href=https://linkerd.io/2/features/automatic-mtls/>Linkerd</a>, where other than encryption you guarantee that both components are trusting each other and they manage entirely the PKI for your mesh.</p><p>You could also setup and manage PKI by yourself by using certificate managers like cert-manager that works with external CAs, for example,b provided by Vault (yes, it can also be used as a root/intermediate CA). Anyway, it&rsquo;s not a good idea since it can be complex, especially in situations where you have microservices… you would freak out.</p><p>A service mesh framework provides also a lot of features; on the security perspective, it can covers also authorization and audit, other than authentication (and encryption), as Istio does with <a href=https://istio.io/latest/docs/concepts/security/#secure-naming>secure naming</a> that maps server identities encoded in certificates with service names and checks against policies, to control if an identity is authorized to run a service.</p><p>But that is only a part of the security aspects that a service mesh covers; it can manage load balancing, access control, observability, canary releasing, etc. They can cover also the authentication from the end-user, other than in communications between services, for example by supporting OpenID Connect providers.
In addition to the encryption of the whole communication, you can and should also encrypt specific sensitive data by leveraging secrets manager like Vault; it also provides <a href=https://learn.hashicorp.com/tutorials/vault/eaas-transit>encryption as a service</a> thanks to its transit secrets engine.</p><p>You can use Vault to generate and manage tokens, which in turn - as said before - can be injected runtime into your workload without being aware of the secrets manager.</p><p>Finally, if you&rsquo;d deploy third-party components consider that Kubernetes expects that all API communication in the cluster is encrypted by default with TLS, and the majority of installation methods will allow the necessary certificates to be created and distributed to the cluster components.</p><p>Anyway some components and installation methods may enable local ports over HTTP, so you should check every setting to identify potentially unsecured traffic and, if supported, enable TLS encryption and if not, look for alternative components that will do.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p><em>&ldquo;The power of a system comes more from the relationships among programs than from the programs themselves&rdquo;</em> (The UNIX Programming Environment).
As the UNIX way probably shaped the Kubernetes architecture the relationships are to be carefully managed and secured as like as the data that transits in and be generated by.</p><p>Whereas this, this part covered a lot of aspects and because of that it has been hard to put practice demos; anyway I tried to provide as much references as I can to let you deepen by yourself the topics you&rsquo;re most interested in.</p><p>That&rsquo;s all folks! I hope you liked this part and to I hope to see you later in the next part about Denial of service.</p><p>Happy hacking!</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://maxgio92.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=http://maxgio92.github.io/tags/security/>security</a></li></ul><nav class=paginav><a class=prev href=http://maxgio92.github.io/posts/k8s-stride-05-denial-of-service/><span class=title>« Prev</span><br><span>STRIDE threat modeling on Kubernetes pt.5/6: Denial of service</span></a>
<a class=next href=http://maxgio92.github.io/posts/k8s-stride-03-repudiation/><span class=title>Next »</span><br><span>STRIDE threat modeling on Kubernetes pt.3/6: Repudiation</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure on twitter" href="https://twitter.com/intent/tweet/?text=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.4%2f6%3a%20Information%20disclosure&url=http%3a%2f%2fmaxgio92.github.io%2fposts%2fk8s-stride-04-information-disclosure%2f&hashtags=kubernetes%2csecurity"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share STRIDE threat modeling on Kubernetes pt.4/6: Information disclosure on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fmaxgio92.github.io%2fposts%2fk8s-stride-04-information-disclosure%2f&title=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.4%2f6%3a%20Information%20disclosure&summary=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.4%2f6%3a%20Information%20disclosure&source=http%3a%2f%2fmaxgio92.github.io%2fposts%2fk8s-stride-04-information-disclosure%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://maxgio92.github.io/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>