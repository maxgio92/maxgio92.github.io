<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege | Maxgio's blog</title><meta name=keywords content="kubernetes,linux,security"><meta name=description content="Hello everyone, a long time has passed after the 5th part of this journey through STRIDE thread modeling in Kubernetes has been published. If you recall well, STRIDE is a model of threats for identifying security threats, by providing a mnemonic for security threats in six categories:
 Spoofing Tampering Repudiation Information disclosure Denial of service Elevation of privilege  In this last chapter we&rsquo;ll talk about elevation of privilege. Well, this category can be very wide, but let&rsquo;s start thinking about what it can comprises and what we can do against this category of threats."><meta name=author content><link rel=canonical href=http://maxgio92.github.io/posts/stride-threat-modeling-kubernetes-elevation-of-privileges/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=http://maxgio92.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://maxgio92.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://maxgio92.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://maxgio92.github.io/apple-touch-icon.png><link rel=mask-icon href=http://maxgio92.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-7DN0LVS78Q','auto');ga('send','pageview');}</script><meta property="og:title" content="STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege"><meta property="og:description" content="Hello everyone, a long time has passed after the 5th part of this journey through STRIDE thread modeling in Kubernetes has been published. If you recall well, STRIDE is a model of threats for identifying security threats, by providing a mnemonic for security threats in six categories:
 Spoofing Tampering Repudiation Information disclosure Denial of service Elevation of privilege  In this last chapter we&rsquo;ll talk about elevation of privilege. Well, this category can be very wide, but let&rsquo;s start thinking about what it can comprises and what we can do against this category of threats."><meta property="og:type" content="article"><meta property="og:url" content="http://maxgio92.github.io/posts/stride-threat-modeling-kubernetes-elevation-of-privileges/"><meta property="og:image" content="http://maxgio92.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-05T14:05:00+02:00"><meta property="article:modified_time" content="2021-07-05T14:05:00+02:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://maxgio92.github.io/papermod-cover.png"><meta name=twitter:title content="STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege"><meta name=twitter:description content="Hello everyone, a long time has passed after the 5th part of this journey through STRIDE thread modeling in Kubernetes has been published. If you recall well, STRIDE is a model of threats for identifying security threats, by providing a mnemonic for security threats in six categories:
 Spoofing Tampering Repudiation Information disclosure Denial of service Elevation of privilege  In this last chapter we&rsquo;ll talk about elevation of privilege. Well, this category can be very wide, but let&rsquo;s start thinking about what it can comprises and what we can do against this category of threats."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://maxgio92.github.io/posts/"},{"@type":"ListItem","position":2,"name":"STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege","item":"http://maxgio92.github.io/posts/stride-threat-modeling-kubernetes-elevation-of-privileges/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege","name":"STRIDE threat modeling on Kubernetes pt.6\/6: Elevation of privilege","description":"Hello everyone, a long time has passed after the 5th part of this journey through STRIDE thread modeling in Kubernetes has been published. If you recall well, STRIDE is a model of threats for identifying security threats, by providing a mnemonic for security threats in six categories:\n Spoofing Tampering Repudiation Information disclosure Denial of service Elevation of privilege  In this last chapter we\u0026rsquo;ll talk about elevation of privilege. Well, this category can be very wide, but let\u0026rsquo;s start thinking about what it can comprises and what we can do against this category of threats.","keywords":["kubernetes","linux","security"],"articleBody":"Hello everyone, a long time has passed after the 5th part of this journey through STRIDE thread modeling in Kubernetes has been published. If you recall well, STRIDE is a model of threats for identifying security threats, by providing a mnemonic for security threats in six categories:\n Spoofing Tampering Repudiation Information disclosure Denial of service Elevation of privilege  In this last chapter we’ll talk about elevation of privilege. Well, this category can be very wide, but let’s start thinking about what it can comprises and what we can do against this category of threats.\nElevation of privilege Elevation or escalation of privileges is gaining higher access than what is granted. This in turn can be leveraged to access unauthorized resources or to cause damage. Also, this attack can be conducted through other different types of attacks, like spoofing, where an actor claims to be a different actor with higher privileges, and so on.\nSo the first question we’d like to answer could be: what we can generally do? I think we can consider from an high-level point of view prevention and detection: prevention can be done via access control, and detection through analysis of audit events - this assumes we have auditing in place.\nIn Kubernetes Role-Based Access Control authorizes or not access to Kubernetes resources through roles, but we also have underlying infrastructure resources, and Kubernetes provides primitives to authorize workload to access operating system resources, like Linux namespaces.\nAll of this is a bit simplicistic for sure, but just consider this as a starting point for reflections: nothing can be 100% secure, and no solution can exists that can cover all scenarios.\nPrevention Prevention is the act to avoid that an action occurs. In this case we’re talking about unwanted actions, like for example that a Pod’s container runs with unwanted capabilities like CAP_SYS_ADMIN.\nKubernetes In Kubenetes access control is mostly achieved with usage of roles. The policies that we need are generally specific on the workload that we run, but the recommendation is to follow deny-by-default approach, and to authorize the more minimum set of capabilities as possible. In detail not using default ServiceAccount, configuring and binding proper permissions, and do not mound Service Account token when not needed, is a good choice.\nAt the same time we should consider that also Kubernetes components like kubelet is authorized to access Kubernetes resources like Secrets through Node Authorization. And not only in-cluster authorized requests, but also ones that are authorized externally, like users that are authenticated and authorized by cloud provider/on-premise IAM services through OIDC or SAML flows.\nFurthermore, authorized workload runs in the clusters and sometimes can make API requests to Kubernetes. In the era of GitOps we let further workload to reconcile workload as we’d desire. So keep in mind which privileges GitOps controllers need and apply least privileg principle also there. The work that Flux team is doing for modeling their API considering complex scenarios like multi-tenancy is great.\nTalking about access control in multi-tenancy scenarios Capsule is an interesting project which can help with managing access control easily.\nOS We’re no longer talking about granting access to Kubenetes resources to Kubernetes workload, instead we’re talking about granting access to OS resources to OS workload, as in the end Pods run as tasks at operating system level. Here is where all the magic happens, and where our containers are composed through Linux namespaces, control groups, capabilities.\nI won’t go in details of specific container escape techniques like Kamil Potrec did here very well, but I’m talking about general approaches and vectors to consider and which prevention we could do. In Kubernetes SecurityContext is what enables or not access to underlying operating system resources to Kubernetes pods.\nAccess control should be in place also at this level, so basically we’d want policies to prevent unwanted privileges.\nPolicy design I’m talking about policies in general, beyond the implementation. When choosing which level of privileges we’d want to allow, let’s consider:\n Prevent containers from running as UID 0 in the container user namespace (with securityContext.runAsUser or specifying it from Dockerfile) Drop capabilities: even with unprivileged user namespaces, apply least needed capabilities. See more here about Linux capabilities with user namespaces. Filtering syscalls: as for capabilities, we can use seccomp to filter system calls by using the container’s securityContext, for example by blocking common syscalls used in techniques like unshare to create new Linux namespaces or userfaultd to control page faults in userspace after triggering overflows. With this regard, Security Profiles Operator would help to automatically generate initial seccomp or AppArmor profiles, specific to applications. Avoid to attach host namespaces unless strictly needed. I found this repo well done to understand it. Preventing privilege escalation: since in Linux by default a child processes is allowed to claim more privileges than the parent, this is not ideal for containers, so use Pod Security Policy to set allowPrivilegeEscalation: false.  Just a note about unprivileged user namespaces and Kubernetes: starting in Linux 3.8, unprivileged processes can create user namespaces, and the other types of namespaces can be created with just the CAP_SYS_ADMIN capability in the caller’s user namespace (Kinvolk explains clearly how it relates to containers here). Rootless containers are based on that, unfortunately Kubernetes doesn’t already support them, but Akihiro Suda is pushing effort on his work in progress to have a “rootless Kubernetes” distribution, which is Usernetes. So, let’s try it and give feedbacks!\nPolicy enforcement What can be used to write and enforce policies and so prevent Pods from running with higher privileges with respect to what we would grant to them is Pod Security Policy feature. It provides API objects to declare policies and a validating and also mutating admission controller to enforce them.\nUnfortunately a non-clear path has been drawn in these years letting us with doubts and limits, and leading in the end to deprecation of Pod Security Policy APIs from 1.21. A KEP is in place, that very briefly proposes a simpler approach based on the Pod Security Standards which identifies three basic levels of policies (Privileged, Baseline, Restricted), appliance of them via annotations at Namespace level and enforcement through a new dedicated admission controller.\nKeep it mind that it should cover different scenarios and easy the migration from PSP, but at the same time for more advanced use cases there are different framework like Gatekeeper that allow us to write fine-grained Rego policies with OPA, but also Kyverno that instead doesn’t require to learn a new language just to name one. Another option is Polaris, which offers admission controllers that prevents also on this.\nAnyway, always consider that for sure the more powerful the solution the higher the granularity and probability to tailor our scenarios, but also IMHO:\n the more complexity we add, the larger could be the attack surface; the steeper the learning curve, the harder could be the effectiveness to be achieved.  Network Don’t forget to think about the network, as also network resources can be used to escalate, such as by getting informations from cloud provider’s metadata API. NetworkPolicies enables to do access control at network level. Kinvolk’s Inspektor Gadget network-policy gadget could help to generate our Network Policy by inspecting our Pods network activity. Then the Network Policy Editor by Cilium can also teach and generate them.\nDetection Kubernetes Kubernetes provides auditing features through dedicated APIs. Audit Events are events that are recorded by the API server as defined for Policy and sent to backends. From the decision on removal of the dynamic backend feature, there’s a proposal on introducing a DynamicAudit Proxy based on static webhook, so this last one remains the fundamental feature to base on.\nOS Auditing at the operating system level can be looked at by inspecting the requests that the containers (and not only) can fire to interact with the OS, so the system calls. Falco is one of the projects that does exactly that, by capturing, inspecting the fired syscalls and filtering the suspictious ones. Alerts can can be shipped to webhook endpoints and with the addition of Falco Sidekick to a lot of backends like object storage services or message queues or chats. Then, also mitigation can be triggered from detection events in Falco, for example with Kubeless.\nFor sure here eBPF plays a fundamental role here as it allow to program the kernel in a safe manner and easily inspect kernel events.\nInspektor Gadget is a collection of tools to do inspection inspired by kubectl-trace plugin which schedules bpftrace programs in Kubernetes clusters. The most relevant gadget for this scope is the traceloop that can help inspecting system calls requested by Pods also in the past. Here what is very interesing is also the capabilities gadget that can help to tailor our Pod container’s SecurityContexts. What we’d need then is a filtering layer that can fill an alert system for suspictious behaviour.\nKnown vulnerabilities Now that we reason about some possible vectors, let’s list known vulnerabilities from which we can defend with detection and prevention.\nCVE-2020-14386 In a couple of words, this can be exploited with kernels before 5.9-rc4. As this privilege escalation work using raw sockets and by default Kubernetes adds CAP_NET_RAW capabilities to the pods, As you may guess, a PodSecurityPolicy that drops this capability can work. But I recommend to dig into it.\nSee here how to detect and mitigate with Falco.\nCVE-2020-8559 The API server in versions from v1.6 to v1.15 and prior to v1.16.13, v1.17.9 and v1.18.6 are vulnerable to an unvalidated re-direct on proxied upgrade requests that could allow an attacker to escalate privileges from a node compromise to a full cluster compromise. So, let’s keep Kubernetes up-to-date.\nAlso, we can leverage a tool to hunt on our cluster for weaknesses, which is kube-hunter. You can run it on an external machine or within the cluster on the machine or in a pod.\nConclusion So we talk about what privilege escalation is, which are the resources that we should protect, both when we do prevention and when we do detection.\nAnother conclusion As we go through this journey I learnt a lot of stuff that was new to me. When preparing this part and re-reading the first ones I thought: “What is this? Was it me? I should not publish this”, and I was going to delete and re-write them. I saw a very different approach, a different consciousness and confusion of what I was talking about.\nBut I thought that this is part of our journey. And I let them published with pride.\nWhat I’m tying to say, is that we have another conclusion. No one will know everything and we always are in a continuous journey. We have a lot of value in sharing what we learn and our thoughts. This is why I opened this blog, because I believe in it.\nSo.. Let’s keep in touch here, on Twitter, Github or anywhere you want!\n","wordCount":"1821","inLanguage":"en","datePublished":"2021-07-05T14:05:00+02:00","dateModified":"2021-07-05T14:05:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://maxgio92.github.io/posts/stride-threat-modeling-kubernetes-elevation-of-privileges/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"http://maxgio92.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=http://maxgio92.github.io/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://maxgio92.github.io/posts title=Posts><span>Posts</span></a></li><li><a href=http://maxgio92.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://maxgio92.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/maxgio92 title=Github><span>Github</span></a></li><li><a href=https://hachyderm.io/@maxgio92 title=Mastodon><span>Mastodon</span></a></li><li><a href=https://twitter.com/maxgio92 title=Twitter><span>Twitter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://maxgio92.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://maxgio92.github.io/posts/>Posts</a></div><h1 class=post-title>STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege</h1><div class=post-meta><span title="2021-07-05 14:05:00 +0200 +0200">July 5, 2021</span>&nbsp;·&nbsp;9 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#elevation-of-privilege aria-label="Elevation of privilege">Elevation of privilege</a><ul><li><a href=#prevention aria-label=Prevention>Prevention</a><ul><li><a href=#kubernetes aria-label=Kubernetes>Kubernetes</a></li><li><a href=#os aria-label=OS>OS</a><ul><li><a href=#policy-design aria-label="Policy design">Policy design</a></li><li><a href=#policy-enforcement aria-label="Policy enforcement">Policy enforcement</a></li></ul></li><li><a href=#network aria-label=Network>Network</a></li></ul></li><li><a href=#detection aria-label=Detection>Detection</a><ul><li><a href=#kubernetes-1 aria-label=Kubernetes>Kubernetes</a></li><li><a href=#os-1 aria-label=OS>OS</a></li></ul></li><li><a href=#known-vulnerabilities aria-label="Known vulnerabilities">Known vulnerabilities</a><ul><li><a href=#cve-2020-14386httpscvemitreorgcgi-bincvenamecginamecve-2020-14386 aria-label=CVE-2020-14386><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-14386">CVE-2020-14386</a></a></li><li><a href=#cve-2020-8559httpscvemitreorgcgi-bincvenamecginamecve-2020-8559 aria-label=CVE-2020-8559><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8559">CVE-2020-8559</a></a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#another-conclusion aria-label="Another conclusion">Another conclusion</a></li></ul></li></ul></div></details></div><div class=post-content><p>Hello everyone, a long time has passed after the 5th part of this journey through STRIDE thread modeling in Kubernetes has been published.
If you recall well, STRIDE is a model of threats for identifying security threats, by providing a mnemonic for security threats in six categories:</p><ul><li>Spoofing</li><li>Tampering</li><li>Repudiation</li><li>Information disclosure</li><li>Denial of service</li><li>Elevation of privilege</li></ul><p>In this last chapter we&rsquo;ll talk about elevation of privilege. Well, this category can be very wide, but let&rsquo;s start thinking about what it can comprises and what we can do against this category of threats.</p><h1 id=elevation-of-privilege>Elevation of privilege<a hidden class=anchor aria-hidden=true href=#elevation-of-privilege>#</a></h1><p>Elevation or escalation of privileges is gaining higher access than what is granted. This in turn can be leveraged to access unauthorized resources or to cause damage.
Also, this attack can be conducted through other different types of attacks, like spoofing, where an actor claims to be a different actor with higher privileges, and so on.</p><p>So the first question we&rsquo;d like to answer could be: what we can generally do? I think we can consider from an high-level point of view <strong>prevention</strong> and <strong>detection</strong>: prevention can be done via access control, and detection through analysis of audit events - this assumes we have auditing in place.</p><p>In Kubernetes Role-Based Access Control authorizes or not access to Kubernetes resources through roles, but we also have underlying infrastructure resources, and Kubernetes provides primitives to authorize workload to access operating system resources, like Linux namespaces.</p><p>All of this is a bit simplicistic for sure, but just consider this as a starting point for reflections: nothing can be 100% secure, and no solution can exists that can cover all scenarios.</p><h2 id=prevention>Prevention<a hidden class=anchor aria-hidden=true href=#prevention>#</a></h2><p>Prevention is the act to avoid that an action occurs. In this case we&rsquo;re talking about unwanted actions, like for example that a Pod&rsquo;s container runs with unwanted capabilities like <a href=https://lwn.net/Articles/486306/><code>CAP_SYS_ADMIN</code></a>.</p><h3 id=kubernetes>Kubernetes<a hidden class=anchor aria-hidden=true href=#kubernetes>#</a></h3><p>In Kubenetes access control is mostly achieved with usage of <a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>roles</a>. The policies that we need are generally specific on the workload that we run, but the recommendation is to follow deny-by-default approach, and to authorize the more minimum set of capabilities as possible.
In detail not using default <code>ServiceAccount</code>, configuring and binding <a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions>proper permissions</a>, and do not mound Service Account token when not needed, is a good choice.</p><p>At the same time we should consider that also Kubernetes components like <code>kubelet</code> is authorized to access Kubernetes resources like <code>Secrets</code> through <a href=https://kubernetes.io/docs/reference/access-authn-authz/node/>Node Authorization</a>.
And not only in-cluster authorized requests, but also ones that are authorized externally, like users that are authenticated and authorized by cloud provider/on-premise IAM services through OIDC or SAML flows.</p><p>Furthermore, authorized workload runs in the clusters and sometimes can make API requests to Kubernetes. In the era of GitOps we let further workload to reconcile workload as we&rsquo;d desire. So keep in mind which privileges GitOps controllers need and apply least privileg principle also there. The work that Flux team is doing for <a href=https://github.com/fluxcd/flux2/pull/582>modeling</a> their API considering complex scenarios like multi-tenancy is great.</p><p>Talking about access control in multi-tenancy scenarios <a href=https://github.com/clastix/capsule>Capsule</a> is an interesting project which can help with managing access control easily.</p><h3 id=os>OS<a hidden class=anchor aria-hidden=true href=#os>#</a></h3><p>We&rsquo;re no longer talking about granting access to Kubenetes resources to Kubernetes workload, instead we&rsquo;re talking about granting access to OS resources to OS workload, as in the end Pods run as tasks at operating system level.
Here is where all the magic happens, and where our containers are composed through Linux <a href=https://man7.org/linux/man-pages/man7/namespaces.7.html>namespaces</a>, <a href=https://www.man7.org/linux/man-pages/man7/cgroups.7.html>control groups</a>, <a href=https://www.man7.org/linux/man-pages/man7/capabilities.7.html>capabilities</a>.</p><p>I won&rsquo;t go in details of specific container escape techniques like Kamil Potrec did <a href=https://snyk.io/blog/kernel-privilege-escalation/>here</a> very well, but I&rsquo;m talking about general approaches and vectors to consider and which prevention we could do.
In Kubernetes <a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/><code>SecurityContext</code></a> is what enables or not access to underlying operating system resources to Kubernetes pods.</p><p>Access control should be in place also at this level, so basically we&rsquo;d want policies to prevent unwanted privileges.</p><h4 id=policy-design>Policy design<a hidden class=anchor aria-hidden=true href=#policy-design>#</a></h4><p>I&rsquo;m talking about policies in general, beyond the implementation. When choosing which level of privileges we&rsquo;d want to allow, let&rsquo;s consider:</p><ul><li>Prevent containers from running as <strong>UID 0</strong> in the container user namespace (with <code>securityContext.runAsUser</code> or specifying it from <code>Dockerfile</code>)</li><li>Drop <strong>capabilities</strong>: even with unprivileged user namespaces, apply <a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-capabilities-for-a-container>least needed capabilities</a>. See more <a href=https://lwn.net/Articles/420624/>here</a> about Linux capabilities with user namespaces.</li><li>Filtering <strong>syscalls</strong>: as for capabilities, we can use <code>seccomp</code> to filter system calls by using the container&rsquo;s <code>securityContext</code>, for example by blocking common syscalls used in techniques like <a href=https://man7.org/linux/man-pages/man2/unshare.2.html><code>unshare</code></a> to create new Linux namespaces or <a href=https://man7.org/linux/man-pages/man2/userfaultfd.2.html><code>userfaultd</code></a> to control page faults in userspace after triggering overflows. With this regard, <a href=https://github.com/kubernetes-sigs/security-profiles-operator>Security Profiles Operator</a> would help to automatically generate initial <code>seccomp</code> or <code>AppArmor</code> profiles, specific to applications.</li><li>Avoid to attach host <strong>namespaces</strong> unless strictly needed. I found <a href=https://github.com/BishopFox/badPods>this</a> repo well done to understand it.</li><li>Preventing privilege escalation: since in Linux by default a child processes is allowed to claim more privileges than the parent, this is not ideal for containers, so use Pod Security Policy to set <code>allowPrivilegeEscalation: false</code>.</li></ul><p>Just a note about unprivileged <a href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html>user namespaces</a> and Kubernetes: starting in Linux 3.8, unprivileged processes can create user namespaces, and the other types of namespaces can be created with just the <code>CAP_SYS_ADMIN</code> capability in the caller&rsquo;s user namespace (Kinvolk explains clearly how it relates to containers <a href=https://kinvolk.io/blog/2020/12/improving-kubernetes-and-container-security-with-user-namespaces/>here</a>).
<a href=https://rootlesscontaine.rs>Rootless containers</a> are <a href=https://rootlesscontaine.rs/how-it-works/userns/>based</a> on that, unfortunately Kubernetes doesn&rsquo;t already <a href=https://github.com/kubernetes/enhancements/pull/2101>support</a> them, but Akihiro Suda is pushing effort on his work in progress to have a &ldquo;rootless Kubernetes&rdquo; distribution, which is <a href=https://github.com/rootless-containers/usernetes><code>Usernetes</code></a>. So, let&rsquo;s try it and give feedbacks!</p><h4 id=policy-enforcement>Policy enforcement<a hidden class=anchor aria-hidden=true href=#policy-enforcement>#</a></h4><p>What can be used to write and enforce policies and so prevent Pods from running with higher privileges with respect to what we would grant to them is Pod Security Policy feature. It provides API objects to declare policies and a validating and also mutating admission controller to enforce them.</p><p>Unfortunately a non-clear path has been drawn in these years letting us with doubts and limits, and leading in the end to <a href=https://kubernetes.io/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future>deprecation</a> of Pod Security Policy APIs from 1.21. A <a href=https://github.com/kubernetes/enhancements/pull/2582>KEP</a> is in place, that very briefly proposes a simpler approach based on the <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Pod Security Standards</a> which identifies three basic levels of policies (<code>Privileged</code>, <code>Baseline</code>, <code>Restricted</code>), appliance of them via annotations at Namespace level and enforcement through a new dedicated admission controller.</p><p>Keep it mind that it should cover different scenarios and easy the migration from PSP, but at the same time for more advanced use cases there are different framework like <a href=https://github.com/open-policy-agent/gatekeeper>Gatekeeper</a> that allow us to write fine-grained Rego policies with OPA, but also <a href=https://github.com/kyverno/kyverno/>Kyverno</a> that instead doesn&rsquo;t require to learn a new language just to name one.
Another option is <a href=https://github.com/FairwindsOps/polaris>Polaris</a>, which offers admission controllers that prevents also on this.</p><p>Anyway, always consider that for sure the more powerful the solution the higher the granularity and probability to tailor our scenarios, but also IMHO:</p><ul><li>the more complexity we add, the larger could be the attack surface;</li><li>the steeper the learning curve, the harder could be the effectiveness to be achieved.</li></ul><h3 id=network>Network<a hidden class=anchor aria-hidden=true href=#network>#</a></h3><p>Don&rsquo;t forget to think about the network, as also network resources can be used to escalate, such as by getting informations from cloud provider&rsquo;s metadata API. <a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/><code>NetworkPolicies</code></a> enables to do access control at network level.
<a href=https://kinvolk.io/>Kinvolk</a>&rsquo;s Inspektor Gadget <a href=https://github.com/kinvolk/inspektor-gadget/blob/master/docs/guides/network-policy.md>network-policy</a> gadget could help to generate our Network Policy by inspecting our Pods network activity. Then the <a href=https://editor.cilium.io/>Network Policy Editor</a> by <a href=https://cilium.io/>Cilium</a> can also teach and generate them.</p><h2 id=detection>Detection<a hidden class=anchor aria-hidden=true href=#detection>#</a></h2><h3 id=kubernetes-1>Kubernetes<a hidden class=anchor aria-hidden=true href=#kubernetes-1>#</a></h3><p>Kubernetes provides auditing features through <a href=https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/>dedicated APIs</a>. Audit <a href=https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event><code>Events</code></a> are events that are recorded by the API server as defined for <a href=https://kubernetes.io/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy><code>Policy</code></a> and sent to <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/audit/#audit-backends>backends</a>.
From the <a href=https://groups.google.com/g/kubernetes-sig-auth/c/aV_nXpa5uWU>decision on removal</a> of the dynamic backend feature, there&rsquo;s a <a href=https://docs.google.com/document/d/16cy_ZD94ooBAvlH-rFOel8RPDWRiGFg4Cz11l4sfEII/edit>proposal</a> on introducing a <code>DynamicAudit Proxy</code> based on static webhook, so this last one remains the fundamental feature to base on.</p><h3 id=os-1>OS<a hidden class=anchor aria-hidden=true href=#os-1>#</a></h3><p>Auditing at the operating system level can be looked at by inspecting the requests that the containers (and not only) can fire to interact with the OS, so the system calls. <a href=https://falco.org>Falco</a> is one of the projects that does exactly that, by capturing, inspecting the fired syscalls and filtering the suspictious ones. Alerts can can be shipped to webhook endpoints and with the addition of <a href=https://github.com/falcosecurity/falcosidekick>Falco Sidekick</a> to a lot of backends like object storage services or message queues or chats.
Then, also mitigation can be triggered from detection events in Falco, for example <a href=https://falco.org/blog/falcosidekick-reponse-engine-part-1-kubeless/>with Kubeless</a>.</p><p>For sure here eBPF plays a fundamental role here as it allow to program the kernel in a safe manner and easily inspect kernel events.</p><p><a href=https://github.com/kinvolk/inspektor-gadget>Inspektor Gadget</a> is a collection of tools to do inspection inspired by <a href=https://github.com/iovisor/kubectl-trace>kubectl-trace</a> plugin which schedules <a href=https://github.com/iovisor/bpftrace>bpftrace</a> programs in Kubernetes clusters. The most relevant gadget for this scope is the <a href=https://github.com/kinvolk/traceloop>traceloop</a> that can help inspecting system calls requested by Pods also in the past.
Here what is very interesing is also the <a href=https://github.com/kinvolk/inspektor-gadget/blob/master/docs/guides/capabilities.md>capabilities</a> gadget that can help to tailor our Pod container&rsquo;s <code>SecurityContext</code>s.
What we&rsquo;d need then is a filtering layer that can fill an alert system for suspictious behaviour.</p><h2 id=known-vulnerabilities>Known vulnerabilities<a hidden class=anchor aria-hidden=true href=#known-vulnerabilities>#</a></h2><p>Now that we reason about some possible vectors, let&rsquo;s list known vulnerabilities from which we can defend with detection and prevention.</p><h3 id=cve-2020-14386httpscvemitreorgcgi-bincvenamecginamecve-2020-14386><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-14386">CVE-2020-14386</a><a hidden class=anchor aria-hidden=true href=#cve-2020-14386httpscvemitreorgcgi-bincvenamecginamecve-2020-14386>#</a></h3><p>In a couple of words, this can be exploited with kernels before 5.9-rc4. As this privilege escalation work using raw sockets and by default Kubernetes adds <code>CAP_NET_RAW</code> capabilities to the pods, As you may guess, a <code>PodSecurityPolicy</code> that drops this capability can work. But I recommend to dig into it.</p><p>See <a href=https://sysdig.com/blog/cve-2020-14386-falco/>here</a> how to detect and mitigate with Falco.</p><h3 id=cve-2020-8559httpscvemitreorgcgi-bincvenamecginamecve-2020-8559><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8559">CVE-2020-8559</a><a hidden class=anchor aria-hidden=true href=#cve-2020-8559httpscvemitreorgcgi-bincvenamecginamecve-2020-8559>#</a></h3><p>The API server in versions from v1.6 to v1.15 and prior to v1.16.13, v1.17.9 and v1.18.6 are vulnerable to an unvalidated re-direct on proxied upgrade requests that could allow an attacker to escalate privileges from a node compromise to a full cluster compromise. So, let&rsquo;s keep Kubernetes up-to-date.</p><p>Also, we can leverage a tool to hunt on our cluster for weaknesses, which is <a href=https://github.com/aquasecurity/kube-hunter>kube-hunter</a>. You can run it on an external machine or within the cluster on the machine or in a pod.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>So we talk about what privilege escalation is, which are the resources that we should protect, both when we do prevention and when we do detection.</p><h2 id=another-conclusion>Another conclusion<a hidden class=anchor aria-hidden=true href=#another-conclusion>#</a></h2><p>As we go through this journey I learnt a lot of stuff that was new to me. When preparing this part and re-reading the first ones I thought: &ldquo;What is this? Was it me? I should not publish this&rdquo;, and I was going to delete and re-write them. I saw a very different approach, a different consciousness and confusion of what I was talking about.</p><p>But I thought that this is part of our journey. And I let them published with pride.</p><p>What I&rsquo;m tying to say, is that we have <strong>another conclusion</strong>. No one will know everything and we <strong>always</strong> are in a continuous <strong>journey</strong>.
We have a lot of value in sharing what we learn and our thoughts. This is why I opened this blog, because I believe in it.</p><p>So.. Let&rsquo;s keep in touch here, on Twitter, Github or anywhere you want!</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://maxgio92.github.io/tags/kubernetes/>kubernetes</a></li><li><a href=http://maxgio92.github.io/tags/linux/>linux</a></li><li><a href=http://maxgio92.github.io/tags/security/>security</a></li></ul><nav class=paginav><a class=prev href=http://maxgio92.github.io/posts/linux-scheduler-journey/><span class=title>« Prev</span><br><span>A journey into the Linux scheduler</span></a>
<a class=next href=http://maxgio92.github.io/posts/k8s-stride-05-denial-of-service/><span class=title>Next »</span><br><span>STRIDE threat modeling on Kubernetes pt.5/6: Denial of service</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege on twitter" href="https://twitter.com/intent/tweet/?text=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.6%2f6%3a%20Elevation%20of%20privilege&url=http%3a%2f%2fmaxgio92.github.io%2fposts%2fstride-threat-modeling-kubernetes-elevation-of-privileges%2f&hashtags=kubernetes%2clinux%2csecurity"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share STRIDE threat modeling on Kubernetes pt.6/6: Elevation of privilege on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2fmaxgio92.github.io%2fposts%2fstride-threat-modeling-kubernetes-elevation-of-privileges%2f&title=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.6%2f6%3a%20Elevation%20of%20privilege&summary=STRIDE%20threat%20modeling%20on%20Kubernetes%20pt.6%2f6%3a%20Elevation%20of%20privilege&source=http%3a%2f%2fmaxgio92.github.io%2fposts%2fstride-threat-modeling-kubernetes-elevation-of-privileges%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://maxgio92.github.io/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>