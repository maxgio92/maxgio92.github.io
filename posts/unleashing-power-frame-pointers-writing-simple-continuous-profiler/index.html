<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler | Maxgio's blog</title><meta name=keywords content="profiling,optimization,ebpf"><meta name=description content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Since we don’t want the application to necessarily be instrumented, we can use the Linux kernel instrumentation. Thanks to eBPF we’re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the introduced overhead by exchanging data with userspace through eBPF maps."><meta name=author content><link rel=canonical href=https://blog.maxgio.me/posts/unleashing-power-frame-pointers-writing-simple-continuous-profiler/><link crossorigin=anonymous href=/assets/css/stylesheet.min.149ea7cdaa83f0ab31471ced9e0495af0272de908dd4a38e5c229d8b0579a758.css integrity="sha256-FJ6nzaqD8KsxRxztngSVrwJy3pCN1KOOXCKdiwV5p1g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://blog.maxgio.me/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.maxgio.me/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.maxgio.me/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.maxgio.me/apple-touch-icon.png><link rel=mask-icon href=https://blog.maxgio.me/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-7DN0LVS78Q','auto');ga('send','pageview');}</script><meta property="og:title" content="Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler"><meta property="og:description" content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Since we don’t want the application to necessarily be instrumented, we can use the Linux kernel instrumentation. Thanks to eBPF we’re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the introduced overhead by exchanging data with userspace through eBPF maps."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.maxgio.me/posts/unleashing-power-frame-pointers-writing-simple-continuous-profiler/"><meta property="og:image" content="https://blog.maxgio.me/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-18T21:00:00+02:00"><meta property="article:modified_time" content="2024-08-18T21:00:00+02:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.maxgio.me/papermod-cover.png"><meta name=twitter:title content="Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler"><meta name=twitter:description content="In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.
In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.
Since we don’t want the application to necessarily be instrumented, we can use the Linux kernel instrumentation. Thanks to eBPF we’re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the introduced overhead by exchanging data with userspace through eBPF maps."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.maxgio.me/posts/"},{"@type":"ListItem","position":2,"name":"Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler","item":"https://blog.maxgio.me/posts/unleashing-power-frame-pointers-writing-simple-continuous-profiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler","name":"Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler","description":"In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.\nIn this blog, we\u0026rsquo;ll see practically how we can build a simple sampling-based continuous profiler.\nSince we don’t want the application to necessarily be instrumented, we can use the Linux kernel instrumentation. Thanks to eBPF we’re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the introduced overhead by exchanging data with userspace through eBPF maps.","keywords":["profiling","optimization","ebpf"],"articleBody":"In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.\nIn this blog, we’ll see practically how we can build a simple sampling-based continuous profiler.\nSince we don’t want the application to necessarily be instrumented, we can use the Linux kernel instrumentation. Thanks to eBPF we’re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the introduced overhead by exchanging data with userspace through eBPF maps.\nThe goal is to calculate statistics about the time spent by a program on specific code paths.\nA possible implementation can be summarized with the following responsibilities:\n to periodically sample stack traces to collect samples to calculate statistics with the samples to resolve instruction pointer to symbols  These responsibilities can be assigned to two main components:\n in kernel space, an eBPF program periodically samples stack traces for a specific process; in userspace, a program loads and attaches the eBPF program to a periodic trigger, filter and consumes the samples to calculate the statistics, and resolves the subroutine’s symbols.  Kernel space The main responsibility of the eBPF program count how often a specific code path is executed and create a histogram of the results. Also, it gathers the stack traces to be accessed from userspace.\nWe’ll use two data structures for this information:\n an histogram eBPF BPF_MAP_TYPE_HASH map a stack traces eBPF BPF_MAP_TYPE_STACK_TRACE map  Histogram We’ll store the histogram of sample counts for a particular code path in a BPF_MAP_TYPE_HASH eBPF hash map:\nstruct { __uint(type, BPF_MAP_TYPE_HASH); __type(key, histogram_key_t); __type(value, u64); __uint(max_entries, K_NUM_MAP_ENTRIES); } histogram SEC(\".maps\"); The key of this map represents the identifier for a particular state-in-point of the stack and is a structure that contains:\n PID; kernel stack ID; user stack ID:  typedef struct histogram_key { u32 pid; u32 kernel_stack_id; u32 user_stack_id; } histogram_key_t; The value of this map is a u64 to store stack trace counts.\nStack traces To get the information about the running code path we can use the bpf_get_stackid eBPF helper.\neBPF helpers are functions that, as you might have guessed, simplify work. The bpf_get_stackid helper collects user and kernel stack frames by walking the user and kernel stacks and returns the ID of the state of the stack at a specific point in time.\nMore precisely from the eBPF Docs:\n Walk a user or a kernel stack and return its id. To achieve this, the helper needs ctx, which is a pointer to the context on which the tracing program is executed, and a pointer to a map of type BPF_MAP_TYPE_STACK_TRACE.\n So, one of the most complex works that is the stack unwinding is abstracted away thanks to this helper.\nFor example, we declare the stack_traces BPF_MAP_TYPE_STACK_TRACE map that contains the list of instruction pointers, and we prepare the histogram key:\nstruct { __uint(type, BPF_MAP_TYPE_STACK_TRACE); __uint(key_size, sizeof(u32)); __uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64)); __uint(max_entries, 10000); } stack_traces SEC(\".maps\"); SEC(\"perf_event\") int sample_stack_trace(struct bpf_perf_event_data* ctx) { histogram_key_t key; // ...  /* Sample the user and kernel stack traces, and record in the stack_traces structure. */ key.pid = bpf_get_current_pid_tgid()  32; key.kernel_stack_id = bpf_get_stackid(ctx, \u0026stack_traces, 0); key.user_stack_id = bpf_get_stackid(ctx, \u0026stack_traces, 0 | BPF_F_USER_STACK); // ... } and for the specific stack trace (key) we update the sample count in the histogram:\nSEC(\"perf_event\") int sample_stack_trace(struct bpf_perf_event_data* ctx) { histogram_key_t key; u64 one = 1; // ...  /* Sample the user and kernel stack traces, and record in the stack_traces structure. */ // ...  /* Upsert stack trace histogram */ count = (u64*)bpf_map_lookup_elem(\u0026histogram, \u0026key); if (count) { (*count)++; } else { bpf_map_update_elem(\u0026histogram, \u0026key, \u0026one, BPF_NOEXIST); } return 0; } We also need to retrieve the stack trace, which is a list of instruction pointers. This information too is abstracted away thanks to the BPF_MAP_TYPE_STACK_TRACE map, and available to userspace.\nstruct { __uint(type, BPF_MAP_TYPE_STACK_TRACE); __uint(key_size, sizeof(u32)); __uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64)); __uint(max_entries, K_NUM_MAP_ENTRIES); } stack_traces SEC(\".maps\"); This is mostly the needed work in kernel space, which is pretty simplified thanks to the Linux kernel instrumentation.\nLet’s see how we can consume this data in userspace.\nUserspace Besides loading and attaching the eBPF sampler probe, in userspace, we collect the stack traces from the stack_traces map. This map is accessible by stack IDs, which are available from the histogram map.\nCollecting stack traces Using the libbpfgo library it can be achieved like that:\nimport ( \"encoding/binary\" \"bytes\" \"unsafe\" ) type HistogramKey struct { Pid int32 // UserStackId, an index into the stack-traces map. \tUserStackId uint32 // KernelStackId, an index into the stack-traces map. \tKernelStackId uint32 } // StackTrace is an array of instruction pointers (IP). // 127 is the size of the profile, as for the default PERF_MAX_STACK_DEPTH. type StackTrace [127]uint64 func Run(ctx context.Context) error { // ... \tfor it := histogram.Iterator(); it.Next(); { k := it.Key() // ... \tvar key HistogramKey if err = binary.Read(bytes.NewBuffer(k), binary.LittleEndian, \u0026key); err != nil { // ... \t} var symbols string if int32(key.UserStackId) = 0 { trace, err := getStackTrace(stackTraces, key.UserStackId) // ... \t} if int32(key.KernelStackId) = 0 { trace, err := getStackTrace(stackTraces, key.KernelStackId) // ... \t} // ... } func getStackTrace(stackTraces *bpf.BPFMap, id uint32) (*StackTrace, error) { stackB, err := stackTraces.GetValue(unsafe.Pointer(\u0026id)) // ...  var stackTrace StackTrace err = binary.Read(bytes.NewBuffer(stackB), binary.LittleEndian, \u0026stackTrace) // ...  return \u0026stackTrace, nil } Calculating statistics Once the sampling is completed, we’re able to calculate the program’s residency fraction for each subroutine, that is, how much a specific subroutine has been run within a time frame:\nresidencyFraction = nTraceSamples / nTotalSamples * 100. You find below the simple code:\nfunc calculateStats() (map[string]float64, error) { // ...  traceSampleCounts := make(map[string]int, 0) totalSampleCount := 0 // Iterate over the stack profile counts histogram map. \tfor it := histogram.Iterator(); it.Next(); { k := it.Key() // ...  // Get count for the specific sampled stack trace. \tcountB, err := histogram.GetValue(unsafe.Pointer(\u0026k[0])) // ... \tcount := int(binary.LittleEndian.Uint64(countB)) // ... \t// Increment the traceSampleCounts map value for the stack trace symbol string (e.g. \"main;subfunc;\") \ttotalSampleCount += count traceSampleCounts[trace] += count } stats := make(map[string]float64, len(traceSampleCounts)) for trace, count := range traceSampleCounts { residencyFraction := float64(count) / float64(totalSampleCount) stats[trace] = residencyFraction } return stats, nil } Finally, because traces are arrays of instruction pointers, we need to translate addresses to symbols.\nSymbolization There are different ways to resolve symbols based on the binary format and the way the binary has been compiled.\nBecause this is a demonstration and the profiler is simple we’ll consider just ELF binaries that are not stripped.\nThe ELF structure contains a symbol table in the .symtab section that holds information needed to locate and relocate a program’s symbolic definitions and references. With that information, we’re able to associate instruction addresses with subroutine names.\nAn entry in the symbol table has the following structure:\ntypedef struct { Elf64_Word\tst_name; unsigned char\tst_info; unsigned char\tst_other; Elf64_Half\tst_shndx; Elf64_Addr\tst_value; Elf64_Xword\tst_size; } Elf64_Sym; The correct symbol name (st_name) for an instruction pointer is the one of which the start (st_value) and end instruction addresses (st_value + st_size) are minor or equal, and major or equal respectively to the instruction pointer address, for each frame in the stack trace.\nBecause the user space program is written in Go, we can leverage the debug/elf package from the standard library to access that information to access ELF data. The elf.File struct exposes a Symbols() function that returns the symbol table for the specific ELF File as a slice of Symbol objects, which in turn expose Value and Size.\nSo, we can match the right symbol for frame’s instruction pointer from the stack trace like below:\nimport \"debug/elf\" // ELFSymTab is one of the possible abstractions around executable // file symbol tables, for ELF files. type ELFSymTab struct { symtab []elf.Symbol } // Load loads from the underlying filesystem the ELF file // with debug/elf.Open and stores it in the ELFSymTab struct. func (e *ELFSymTab) Load(pathname string) error { // ... \tfile, err := elf.Open(pathname) // ... \tsyms, err := file.Symbols() // ... \te.symtab = syms return nil } // GetSymbol returns symbol name from an instruction pointer address // reading the ELF symbol table. func (e *ELFSymTab) GetSymbol(ip uint64) (string, error) { var sym string // ... \tfor _, s := range e.symtab { if ip = s.Value \u0026\u0026 ip  (s.Value+s.Size) { sym = s.Name } } return sym, nil } Program executable path To access the ELF binary we need the process’s binary pathname. The pathname can be retrieved in kernel space from the task_struct’s user space memory mapping descriptor (task_struct-mm_struct-exe_file-f_path) that we can pass through an eBPF map to userspace.\nBecause this data needs to be shared with userspace in order to read from the ELF symbol table, we can declare a map like the following:\nThis hash map stores the binary program file path for each process:\nstruct { __uint(type, BPF_MAP_TYPE_HASH); __type(key, u32);\t/* pid */ __type(value, char[MAX_ARRAY_SIZE]);\t/* exe_path */ __uint(max_entries, K_NUM_MAP_ENTRIES); } binprm_info SEC(\".maps\"); that is updated accordingly alongside the histogram:\nSEC(\"perf_event\") int sample_stack_trace(struct bpf_perf_event_data* ctx) { // ... \tstruct task_struct *task; /* Get current task executable pathname */ task = (struct task_struct *)bpf_get_current_task(); /* Current task struct */ exe_path = get_task_exe_pathname(task); if (exe_path == NULL) { return 0; } len = bpf_core_read_str(\u0026exe_path_str, sizeof(exe_path_str), exe_path); if (len  0) { return 0; } // ... \t/* Upsert stack trace histogram */ count = (u64*)bpf_map_lookup_elem(\u0026histogram, \u0026key); if (count) { (*count)++; } else { bpf_map_update_elem(\u0026histogram, \u0026key, \u0026one, BPF_NOEXIST); bpf_map_update_elem(\u0026binprm_info, \u0026key.pid, \u0026exe_path_str, BPF_ANY); // ... \t} } The userspace program will then consume the exe_path for the profiled process to access the .symtab ELF section.\nSEC(\"perf_event\") int sample_stack_trace(struct bpf_perf_event_data* ctx) { // ... \t/* Get current task executable pathname */ task = (struct task_struct *)bpf_get_current_task(); /* Current task struct */ exe_path = get_task_exe_pathname(task); // ... } /* * get_task_exe_pathname returns the task exe_file pathname. * This does not apply to kernel threads as they share the same memory-mapped address space, * as opposed to user address space. */ static __always_inline void *get_task_exe_pathname(struct task_struct *task) { /* * Get ref file path from the task's user space memory mapping descriptor. * exe_file-f_path could also be accessed from current task's binprm struct * (ctx-args[2]-file-f_path) */ struct path path = BPF_CORE_READ(task, mm, exe_file, f_path); buffer_t *string_buf = get_buffer(0); if (string_buf == NULL) { return NULL; } /* Write path string from path struct to the buffer */ size_t buf_off = get_pathname_from_path(\u0026path, string_buf); return \u0026string_buf-data[buf_off]; } To retrieve the pathname from the path struct we need to walk the directory hierarchy until reaching the root directory of the same VFS mount. For the sake of simplicity, we don’t go into the details of this part.\nThe eBPF program trigger To run the eBPF program with a fixed frequency the Perf subsystem exposes a kernel software event of type CPU clock (PERF_COUNT_SW_CPU_CLOCK) with user APIs. Luckily, eBPF programs can be attached to those events.\nSo, after the program is loaded:\nimport ( bpf \"github.com/aquasecurity/libbpfgo\" \"github.com/pkg/errors\" \"golang.org/x/sys/unix\"implements access to ELF object files. ) func loadAndAttach(probe []byte) error { bpfModule, err := bpf.NewModuleFromBuffer(probe, \"sample_stack_trace\") // ... \tdefer bpfModule.Close() if err := bpfModule.BPFLoadObject(); err != nil { // ... \t} prog, err := bpfModule.GetProgram(\"sample_stack_trace\") if err != nil { // ... \t} // ... } this Perf event can be leveraged to run the sampler by interrupting the CPUs every x milliseconds independently of the process running. Because Perf exposes user APIs, the userspace program can prepare the clock software events and attach the loaded BPF_PROG_TYPE_PERF_EVENT eBPF program to them:\nimport ( bpf \"github.com/aquasecurity/libbpfgo\" \"github.com/pkg/errors\" \"golang.org/x/sys/unix\" ) func loadAndAttach(probe []byte) error { // Load the program...  cpus := runtime.NumCPU() for i := 0; i  cpus; i++ { attr := \u0026unix.PerfEventAttr{ Type: unix.PERF_TYPE_SOFTWARE,\t// If type is PERF_TYPE_SOFTWARE, we are measuring software events provided by the kernel. \tConfig: unix.PERF_COUNT_SW_CPU_CLOCK,\t// This reports the CPU clock, a high-resolution per-CPU timer. \t// A \"sampling\" event is one that generates an overflow notification every N events, \t// where N is given by sample_period. \t// sample_freq can be used if you wish to use frequency rather than period. \t// sample_period and sample_freq are mutually exclusive. \t// The kernel will adjust the sampling period to try and achieve the desired rate. \tSample: 10 * 1000 * 1000, } // Create the perf event file descriptor that corresponds to one event that is measured. \t// We're measuring a clock timer software event just to run the program on a periodic schedule. \t// When a specified number of clock samples occur, the kernel will trigger the program. \tevt, err := unix.PerfEventOpen( attr,\t// The attribute set. \t-1,\t// All the tasks. \ti,\t// on the Nth CPU. \t-1,\t// The group_fd argument allows event groups to be created. \t0,\t// The flags. \t) // ... \thttps://blog.px.dev/static/7b13192052f268bfd22577215d0c9f01/sample-stack-trace-function.png \t// Attach the BPF program to the sampling perf event. \tif _, err = prog.AttachPerfEvent(evt); err != nil { return errors.Wrap(err, \"error attaching the BPF probe to the sampling perf event\") } } return nil }  In this example we’re using the libbpfgo library.\n Wrapping up The user program loads the eBPF program, attaches it to the Perf event in order to be triggered periodically, and samples stack traces. Trace instruction pointers are resolved into symbols and before returning, the statistics about residency fraction are calculated with data stored in the histogram.\nThe statistics are finally printed out like below:\n80% main();foo();bar() 20% main();foo();baz() You can see a full working example at github.com/maxgio92/yap. YAP is a sampling-based, low overhead kernel-assisted profiler I started for learning eBPF and how a program is executed by the CPU.\nNext I personally would like to use statistics to build graph structures, like flamegraphs.\nAlso, I’d like to investigate other ways to extend symbolization support for stripped binaries and collect traces when binaries are built without frame pointers.\nThanks Thanks for your time, I hope you enjoyed this blog.\nI want to special thank Pixie for their knowledge sharing on their blog, and the Linux project for BPF code samples.\nAny form of feedback is more than welcome. Hear from you soon!\nReferences  https://blog.px.dev/cpu-profiling/ https://github.com/torvalds/linux/blob/v6.8/samples/bpf/trace_event_kern.c https://refspecs.linuxbase.org/elf/ https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY https://0xax.gitbooks.io/linux-insides/content/index.html https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them  ","wordCount":"2349","inLanguage":"en","datePublished":"2024-08-18T21:00:00+02:00","dateModified":"2024-08-18T21:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.maxgio.me/posts/unleashing-power-frame-pointers-writing-simple-continuous-profiler/"},"publisher":{"@type":"Organization","name":"Maxgio's blog","logo":{"@type":"ImageObject","url":"https://blog.maxgio.me/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://blog.maxgio.me/ accesskey=h title="Maxgio's blog (Alt + H)">Maxgio's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://blog.maxgio.me/posts title=Posts><span>Posts</span></a></li><li><a href=https://blog.maxgio.me/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.maxgio.me/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/maxgio92 title=Github><span>Github</span></a></li><li><a href=https://hachyderm.io/@maxgio92 title=Mastodon><span>Mastodon</span></a></li><li><a href=https://twitter.com/maxgio92 title=Twitter><span>Twitter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.maxgio.me/>Home</a>&nbsp;»&nbsp;<a href=https://blog.maxgio.me/posts/>Posts</a></div><h1 class=post-title>Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler</h1><div class=post-meta><span title="2024-08-18 21:00:00 +0200 +0200">August 18, 2024</span>&nbsp;·&nbsp;12 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#kernel-space aria-label="Kernel space">Kernel space</a><ul><li><a href=#histogram aria-label=Histogram>Histogram</a></li><li><a href=#stack-traces aria-label="Stack traces">Stack traces</a></li></ul></li><li><a href=#userspace aria-label=Userspace>Userspace</a><ul><li><a href=#collecting-stack-traces aria-label="Collecting stack traces">Collecting stack traces</a></li><li><a href=#calculating-statistics aria-label="Calculating statistics">Calculating statistics</a></li><li><a href=#symbolization aria-label=Symbolization>Symbolization</a><ul><li><a href=#program-executable-path aria-label="Program executable path">Program executable path</a></li></ul></li></ul></li><li><a href=#the-ebpf-program-trigger aria-label="The eBPF program trigger">The eBPF program trigger</a></li><li><a href=#wrapping-up aria-label="Wrapping up">Wrapping up</a></li><li><a href=#next aria-label=Next>Next</a></li><li><a href=#thanks aria-label=Thanks>Thanks</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>In the previous blog about the program execution environment, we introduced the concept of stack unwinding with frame pointers as one of the techniques leveraged for profiling a program.</p><p>In this blog, we&rsquo;ll see practically how we can build a simple sampling-based continuous profiler.</p><p>Since we don’t want the application to necessarily be instrumented, we can use the Linux kernel instrumentation. Thanks to eBPF we’re able to dynamically load and attach the profiler program to specific kernel entry points, limiting the introduced overhead by exchanging data with userspace through eBPF maps.</p><p>The goal is to calculate statistics about the time spent by a program on specific code paths.</p><p>A possible implementation can be summarized with the following responsibilities:</p><ul><li>to periodically sample stack traces</li><li>to collect samples</li><li>to calculate statistics with the samples</li><li>to resolve instruction pointer to symbols</li></ul><p>These responsibilities can be assigned to two main components:</p><ul><li>in kernel space, an eBPF program periodically samples stack traces for a specific process;</li><li>in userspace, a program loads and attaches the eBPF program to a periodic trigger, filter and consumes the samples to calculate the statistics, and resolves the subroutine&rsquo;s symbols.</li></ul><h2 id=kernel-space>Kernel space<a hidden class=anchor aria-hidden=true href=#kernel-space>#</a></h2><p>The main responsibility of the eBPF program count how often a specific code path is executed and create a histogram of the results. Also, it gathers the stack traces to be accessed from userspace.</p><p>We&rsquo;ll use two data structures for this information:</p><ul><li>an histogram eBPF <code>BPF_MAP_TYPE_HASH</code> map</li><li>a stack traces eBPF <code>BPF_MAP_TYPE_STACK_TRACE</code> map</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/maxgio92/notes/465c142604835037dfc08a9acf753d9177a9af94/content/images/yap_maps_stack_traces_histogram.svg alt=histogram_stack_traces_structs></p><h3 id=histogram>Histogram<a hidden class=anchor aria-hidden=true href=#histogram>#</a></h3><p>We&rsquo;ll store the histogram of sample counts for a particular code path in a <code>BPF_MAP_TYPE_HASH</code> eBPF hash map:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=p>{</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>);</span>
	<span class=n>__type</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>histogram_key_t</span><span class=p>);</span>
	<span class=n>__type</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>u64</span><span class=p>);</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=n>K_NUM_MAP_ENTRIES</span><span class=p>);</span>
<span class=p>}</span> <span class=n>histogram</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>
</code></pre></div><p>The key of this map represents the identifier for a particular state-in-point of the stack and is a structure that contains:</p><ul><li>PID;</li><li>kernel stack ID;</li><li>user stack ID:</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>histogram_key</span> <span class=p>{</span>
	<span class=n>u32</span> <span class=n>pid</span><span class=p>;</span>
	<span class=n>u32</span> <span class=n>kernel_stack_id</span><span class=p>;</span>
	<span class=n>u32</span> <span class=n>user_stack_id</span><span class=p>;</span>
<span class=p>}</span> <span class=n>histogram_key_t</span><span class=p>;</span>
</code></pre></div><p>The value of this map is a <code>u64</code> to store stack trace counts.</p><h3 id=stack-traces>Stack traces<a hidden class=anchor aria-hidden=true href=#stack-traces>#</a></h3><p>To get the information about the running code path we can use the <code>bpf_get_stackid</code> eBPF helper.</p><p>eBPF helpers are functions that, as you might have guessed, simplify work. The <a href=https://elixir.bootlin.com/linux/v6.8.5/source/kernel/bpf/stackmap.c#L283><code>bpf_get_stackid</code></a> helper collects user and kernel stack frames by walking the user and kernel stacks and returns the ID of the state of the stack at a specific point in time.</p><p>More precisely from the <a href=https://ebpf-docs.dylanreimerink.nl/linux/helper-function/bpf_get_stackid/>eBPF Docs</a>:</p><blockquote><p>Walk a user or a kernel stack and return its <code>id</code>. To achieve this, the helper needs <code>ctx</code>, which is a pointer to the context on which the tracing program is executed, and a pointer to a map of type <code>BPF_MAP_TYPE_STACK_TRACE</code>.</p></blockquote><p>So, one of the most complex works that is the stack unwinding is abstracted away thanks to this helper.</p><p>For example, we declare the <code>stack_traces</code> <code>BPF_MAP_TYPE_STACK_TRACE</code> map that contains the list of instruction pointers, and we prepare the <code>histogram</code> key:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=p>{</span>
    <span class=n>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_STACK_TRACE</span><span class=p>);</span>
    <span class=n>__uint</span><span class=p>(</span><span class=n>key_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>u32</span><span class=p>));</span>
    <span class=n>__uint</span><span class=p>(</span><span class=n>value_size</span><span class=p>,</span> <span class=n>PERF_MAX_STACK_DEPTH</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>u64</span><span class=p>));</span>
    <span class=n>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=mi>10000</span><span class=p>);</span>
<span class=p>}</span> <span class=n>stack_traces</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>

<span class=n>SEC</span><span class=p>(</span><span class=s>&#34;perf_event&#34;</span><span class=p>)</span>
<span class=kt>int</span> <span class=n>sample_stack_trace</span><span class=p>(</span><span class=k>struct</span> <span class=n>bpf_perf_event_data</span><span class=o>*</span> <span class=n>ctx</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>histogram_key_t</span> <span class=n>key</span><span class=p>;</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=cm>/* Sample the user and kernel stack traces, and record in the stack_traces structure. */</span>
	<span class=n>key</span><span class=p>.</span><span class=n>pid</span> <span class=o>=</span> <span class=n>bpf_get_current_pid_tgid</span><span class=p>()</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>;</span>
	<span class=n>key</span><span class=p>.</span><span class=n>kernel_stack_id</span> <span class=o>=</span> <span class=n>bpf_get_stackid</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_traces</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
	<span class=n>key</span><span class=p>.</span><span class=n>user_stack_id</span> <span class=o>=</span> <span class=n>bpf_get_stackid</span><span class=p>(</span><span class=n>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>stack_traces</span><span class=p>,</span> <span class=mi>0</span> <span class=o>|</span> <span class=n>BPF_F_USER_STACK</span><span class=p>);</span>
	<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>and for the specific stack trace (<code>key</code>) we update the sample count in the <code>histogram</code>:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;perf_event&#34;</span><span class=p>)</span>
<span class=kt>int</span> <span class=n>sample_stack_trace</span><span class=p>(</span><span class=k>struct</span> <span class=n>bpf_perf_event_data</span><span class=o>*</span> <span class=n>ctx</span><span class=p>)</span>
<span class=p>{</span>
	<span class=n>histogram_key_t</span> <span class=n>key</span><span class=p>;</span>
	<span class=n>u64</span> <span class=n>one</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=cm>/* Sample the user and kernel stack traces, and record in the stack_traces structure. */</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=cm>/* Upsert stack trace histogram */</span>
	<span class=n>count</span> <span class=o>=</span> <span class=p>(</span><span class=n>u64</span><span class=o>*</span><span class=p>)</span><span class=n>bpf_map_lookup_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>histogram</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>);</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=p>)</span> <span class=p>{</span>
		<span class=p>(</span><span class=o>*</span><span class=n>count</span><span class=p>)</span><span class=o>++</span><span class=p>;</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=n>bpf_map_update_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>histogram</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>one</span><span class=p>,</span> <span class=n>BPF_NOEXIST</span><span class=p>);</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>We also need to retrieve the stack trace, which is a list of instruction pointers. This information too is abstracted away thanks to the <a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/uapi/linux/bpf.h#L914><code>BPF_MAP_TYPE_STACK_TRACE</code></a> map, and available to userspace.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=p>{</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_STACK_TRACE</span><span class=p>);</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>key_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>u32</span><span class=p>));</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>value_size</span><span class=p>,</span> <span class=n>PERF_MAX_STACK_DEPTH</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>u64</span><span class=p>));</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=n>K_NUM_MAP_ENTRIES</span><span class=p>);</span>
<span class=p>}</span> <span class=n>stack_traces</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>
</code></pre></div><p>This is mostly the needed work in kernel space, which is pretty simplified thanks to the Linux kernel instrumentation.</p><p>Let&rsquo;s see how we can consume this data in userspace.</p><h2 id=userspace>Userspace<a hidden class=anchor aria-hidden=true href=#userspace>#</a></h2><p>Besides loading and attaching the eBPF sampler probe, in userspace, we collect the stack traces from the <code>stack_traces</code> map. This map is accessible by stack IDs, which are available from the <code>histogram</code> map.</p><h3 id=collecting-stack-traces>Collecting stack traces<a hidden class=anchor aria-hidden=true href=#collecting-stack-traces>#</a></h3><p>Using the <a href=https://github.com/aquasecurity/libbpfgo>libbpfgo</a> library it can be achieved like that:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=p>(</span>
	<span class=s>&#34;encoding/binary&#34;</span>
	<span class=s>&#34;bytes&#34;</span>
	<span class=s>&#34;unsafe&#34;</span>
<span class=p>)</span>

<span class=kd>type</span> <span class=nx>HistogramKey</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>Pid</span> <span class=kt>int32</span>

	<span class=c1>// UserStackId, an index into the stack-traces map.
</span><span class=c1></span>	<span class=nx>UserStackId</span> <span class=kt>uint32</span>

	<span class=c1>// KernelStackId, an index into the stack-traces map.
</span><span class=c1></span>	<span class=nx>KernelStackId</span> <span class=kt>uint32</span>
<span class=p>}</span>

<span class=c1>// StackTrace is an array of instruction pointers (IP).
</span><span class=c1>// 127 is the size of the profile, as for the default PERF_MAX_STACK_DEPTH.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>StackTrace</span> <span class=p>[</span><span class=mi>127</span><span class=p>]</span><span class=kt>uint64</span>

<span class=kd>func</span> <span class=nf>Run</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>it</span> <span class=o>:=</span> <span class=nx>histogram</span><span class=p>.</span><span class=nf>Iterator</span><span class=p>();</span> <span class=nx>it</span><span class=p>.</span><span class=nf>Next</span><span class=p>();</span> <span class=p>{</span>
		<span class=nx>k</span> <span class=o>:=</span> <span class=nx>it</span><span class=p>.</span><span class=nf>Key</span><span class=p>()</span>

		<span class=c1>// ...
</span><span class=c1></span>		
		<span class=kd>var</span> <span class=nx>key</span> <span class=nx>HistogramKey</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>binary</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewBuffer</span><span class=p>(</span><span class=nx>k</span><span class=p>),</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>key</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=c1>// ...
</span><span class=c1></span>		<span class=p>}</span>

		<span class=kd>var</span> <span class=nx>symbols</span> <span class=kt>string</span>
		<span class=k>if</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>key</span><span class=p>.</span><span class=nx>UserStackId</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=nx>trace</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>getStackTrace</span><span class=p>(</span><span class=nx>stackTraces</span><span class=p>,</span> <span class=nx>key</span><span class=p>.</span><span class=nx>UserStackId</span><span class=p>)</span>
			<span class=c1>// ...
</span><span class=c1></span>		<span class=p>}</span>
		<span class=k>if</span> <span class=nb>int32</span><span class=p>(</span><span class=nx>key</span><span class=p>.</span><span class=nx>KernelStackId</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=nx>trace</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>getStackTrace</span><span class=p>(</span><span class=nx>stackTraces</span><span class=p>,</span> <span class=nx>key</span><span class=p>.</span><span class=nx>KernelStackId</span><span class=p>)</span>
			<span class=c1>// ...
</span><span class=c1></span>		<span class=p>}</span>
		<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>

<span class=kd>func</span> <span class=nf>getStackTrace</span><span class=p>(</span><span class=nx>stackTraces</span> <span class=o>*</span><span class=nx>bpf</span><span class=p>.</span><span class=nx>BPFMap</span><span class=p>,</span> <span class=nx>id</span> <span class=kt>uint32</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>StackTrace</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=nx>stackB</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>stackTraces</span><span class=p>.</span><span class=nf>GetValue</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>id</span><span class=p>))</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=kd>var</span> <span class=nx>stackTrace</span> <span class=nx>StackTrace</span>
	<span class=nx>err</span> <span class=p>=</span> <span class=nx>binary</span><span class=p>.</span><span class=nf>Read</span><span class=p>(</span><span class=nx>bytes</span><span class=p>.</span><span class=nf>NewBuffer</span><span class=p>(</span><span class=nx>stackB</span><span class=p>),</span> <span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>stackTrace</span><span class=p>)</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>stackTrace</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><h3 id=calculating-statistics>Calculating statistics<a hidden class=anchor aria-hidden=true href=#calculating-statistics>#</a></h3><p>Once the sampling is completed, we&rsquo;re able to calculate the program&rsquo;s residency fraction for each subroutine, that is, how much a specific subroutine has been run within a time frame:</p><pre><code>residencyFraction = nTraceSamples / nTotalSamples * 100.
</code></pre><p>You find below the simple code:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>calculateStats</span><span class=p>()</span> <span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>float64</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>
	<span class=nx>traceSampleCounts</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
	<span class=nx>totalSampleCount</span> <span class=o>:=</span> <span class=mi>0</span>
	
	<span class=c1>// Iterate over the stack profile counts histogram map.
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>it</span> <span class=o>:=</span> <span class=nx>histogram</span><span class=p>.</span><span class=nf>Iterator</span><span class=p>();</span> <span class=nx>it</span><span class=p>.</span><span class=nf>Next</span><span class=p>();</span> <span class=p>{</span>
		<span class=nx>k</span> <span class=o>:=</span> <span class=nx>it</span><span class=p>.</span><span class=nf>Key</span><span class=p>()</span>

		<span class=c1>// ...
</span><span class=c1></span>
		<span class=c1>// Get count for the specific sampled stack trace.
</span><span class=c1></span>		<span class=nx>countB</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>histogram</span><span class=p>.</span><span class=nf>GetValue</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>k</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
		<span class=c1>// ...
</span><span class=c1></span>		<span class=nx>count</span> <span class=o>:=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>binary</span><span class=p>.</span><span class=nx>LittleEndian</span><span class=p>.</span><span class=nf>Uint64</span><span class=p>(</span><span class=nx>countB</span><span class=p>))</span>

		<span class=c1>// ...
</span><span class=c1></span>		
		<span class=c1>// Increment the traceSampleCounts map value for the stack trace symbol string (e.g. &#34;main;subfunc;&#34;)
</span><span class=c1></span>		<span class=nx>totalSampleCount</span> <span class=o>+=</span> <span class=nx>count</span>
		<span class=nx>traceSampleCounts</span><span class=p>[</span><span class=nx>trace</span><span class=p>]</span> <span class=o>+=</span> <span class=nx>count</span>
	<span class=p>}</span>
	
	<span class=nx>stats</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>float64</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>traceSampleCounts</span><span class=p>))</span>
	<span class=k>for</span> <span class=nx>trace</span><span class=p>,</span> <span class=nx>count</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>traceSampleCounts</span> <span class=p>{</span>
		<span class=nx>residencyFraction</span> <span class=o>:=</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>count</span><span class=p>)</span> <span class=o>/</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>totalSampleCount</span><span class=p>)</span>
		<span class=nx>stats</span><span class=p>[</span><span class=nx>trace</span><span class=p>]</span> <span class=p>=</span> <span class=nx>residencyFraction</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>stats</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><p>Finally, because traces are arrays of instruction pointers, we need to translate addresses to symbols.</p><h3 id=symbolization>Symbolization<a hidden class=anchor aria-hidden=true href=#symbolization>#</a></h3><p>There are different ways to resolve symbols based on the binary format and the way the binary has been compiled.</p><p>Because this is a demonstration and the profiler is simple we&rsquo;ll consider just ELF binaries that are not stripped.</p><p>The ELF structure contains a <a href=https://refspecs.linuxbase.org/elf/gabi4+/ch4.symtab.html>symbol table</a> in the <code>.symtab</code> section that holds information needed to locate and relocate a program&rsquo;s symbolic definitions and references. With that information, we&rsquo;re able to associate instruction addresses with subroutine names.</p><p>An entry in the symbol table has the following structure:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
	<span class=n>Elf64_Word</span>	<span class=n>st_name</span><span class=p>;</span>
	<span class=kt>unsigned</span> <span class=kt>char</span>	<span class=n>st_info</span><span class=p>;</span>
	<span class=kt>unsigned</span> <span class=kt>char</span>	<span class=n>st_other</span><span class=p>;</span>
	<span class=n>Elf64_Half</span>	<span class=n>st_shndx</span><span class=p>;</span>
	<span class=n>Elf64_Addr</span>	<span class=n>st_value</span><span class=p>;</span>
	<span class=n>Elf64_Xword</span>	<span class=n>st_size</span><span class=p>;</span>
<span class=p>}</span> <span class=n>Elf64_Sym</span><span class=p>;</span>
</code></pre></div><p>The correct symbol name (<code>st_name</code>) for an instruction pointer is the one of which the start (<code>st_value</code>) and end instruction addresses (<code>st_value</code> + <code>st_size</code>) are minor or equal, and major or equal respectively to the instruction pointer address, for each frame in the stack trace.</p><p>Because the user space program is written in Go, we can leverage the <code>debug/elf</code> package from the standard library to access that information to access ELF data.
The <a href=https://pkg.go.dev/debug/elf#File.Symbols><code>elf.File</code></a> struct exposes a <a href=https://pkg.go.dev/debug/elf#File.Symbols><code>Symbols()</code></a> function that returns the symbol table for the specific ELF <code>File</code> as a slice of <a href=https://pkg.go.dev/debug/elf#Symbol><code>Symbol</code></a> objects, which in turn expose <code>Value</code> and <code>Size</code>.</p><p>So, we can match the right symbol for frame&rsquo;s instruction pointer from the stack trace like below:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=s>&#34;debug/elf&#34;</span>

<span class=c1>// ELFSymTab is one of the possible abstractions around executable
</span><span class=c1>// file symbol tables, for ELF files.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>ELFSymTab</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>symtab</span> <span class=p>[]</span><span class=nx>elf</span><span class=p>.</span><span class=nx>Symbol</span>
<span class=p>}</span>

<span class=c1>// Load loads from the underlying filesystem the ELF file
</span><span class=c1>// with debug/elf.Open and stores it in the ELFSymTab struct.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>ELFSymTab</span><span class=p>)</span> <span class=nf>Load</span><span class=p>(</span><span class=nx>pathname</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>elf</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>pathname</span><span class=p>)</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>syms</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Symbols</span><span class=p>()</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=nx>e</span><span class=p>.</span><span class=nx>symtab</span> <span class=p>=</span> <span class=nx>syms</span>

	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>

<span class=c1>// GetSymbol returns symbol name from an instruction pointer address
</span><span class=c1>// reading the ELF symbol table.
</span><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>e</span> <span class=o>*</span><span class=nx>ELFSymTab</span><span class=p>)</span> <span class=nf>GetSymbol</span><span class=p>(</span><span class=nx>ip</span> <span class=kt>uint64</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>sym</span> <span class=kt>string</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>s</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>e</span><span class=p>.</span><span class=nx>symtab</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>ip</span> <span class=o>&gt;=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Value</span> <span class=o>&amp;&amp;</span> <span class=nx>ip</span> <span class=p>&lt;</span> <span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>Value</span><span class=o>+</span><span class=nx>s</span><span class=p>.</span><span class=nx>Size</span><span class=p>)</span> <span class=p>{</span>
			<span class=nx>sym</span> <span class=p>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>Name</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=nx>sym</span><span class=p>,</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><h4 id=program-executable-path>Program executable path<a hidden class=anchor aria-hidden=true href=#program-executable-path>#</a></h4><p>To access the ELF binary we need the process&rsquo;s binary pathname. The pathname can be retrieved in kernel space from the <code>task_struct</code>&rsquo;s user space memory mapping descriptor (<a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/sched.h#L748><code>task_struct</code></a>-><a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/mm_types.h#L734><code>mm_struct</code></a>-><a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/mm_types.h#L905><code>exe_file</code></a>-><a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/fs.h#L1016><code>f_path</code></a>) that we can pass through an eBPF map to userspace.</p><p>Because this data needs to be shared with userspace in order to read from the ELF symbol table, we can declare a map like the following:</p><p><img loading=lazy src=https://raw.githubusercontent.com/maxgio92/notes/465c142604835037dfc08a9acf753d9177a9af94/content/images/yap_maps_binprm_info.svg alt=binprm_info_map></p><p>This hash map stores the binary program file path for each process:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>struct</span> <span class=p>{</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>type</span><span class=p>,</span> <span class=n>BPF_MAP_TYPE_HASH</span><span class=p>);</span>
	<span class=n>__type</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>u32</span><span class=p>);</span>			<span class=cm>/* pid */</span>
	<span class=n>__type</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=kt>char</span><span class=p>[</span><span class=n>MAX_ARRAY_SIZE</span><span class=p>]);</span>	<span class=cm>/* exe_path */</span>
	<span class=n>__uint</span><span class=p>(</span><span class=n>max_entries</span><span class=p>,</span> <span class=n>K_NUM_MAP_ENTRIES</span><span class=p>);</span>
<span class=p>}</span> <span class=n>binprm_info</span> <span class=n>SEC</span><span class=p>(</span><span class=s>&#34;.maps&#34;</span><span class=p>);</span>
</code></pre></div><p>that is updated accordingly alongside the histogram:</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;perf_event&#34;</span><span class=p>)</span>
<span class=kt>int</span> <span class=n>sample_stack_trace</span><span class=p>(</span><span class=k>struct</span> <span class=n>bpf_perf_event_data</span><span class=o>*</span> <span class=n>ctx</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>task</span><span class=p>;</span>

	<span class=cm>/* Get current task executable pathname */</span>
	<span class=n>task</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=p>)</span><span class=n>bpf_get_current_task</span><span class=p>();</span> <span class=cm>/* Current task struct */</span>
	<span class=n>exe_path</span> <span class=o>=</span> <span class=n>get_task_exe_pathname</span><span class=p>(</span><span class=n>task</span><span class=p>);</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>exe_path</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=n>len</span> <span class=o>=</span> <span class=n>bpf_core_read_str</span><span class=p>(</span><span class=o>&amp;</span><span class=n>exe_path_str</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>exe_path_str</span><span class=p>),</span> <span class=n>exe_path</span><span class=p>);</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>len</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
	<span class=p>}</span>

	<span class=c1>// ...
</span><span class=c1></span>	<span class=cm>/* Upsert stack trace histogram */</span>
	<span class=n>count</span> <span class=o>=</span> <span class=p>(</span><span class=n>u64</span><span class=o>*</span><span class=p>)</span><span class=n>bpf_map_lookup_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>histogram</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>);</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>count</span><span class=p>)</span> <span class=p>{</span>
		<span class=p>(</span><span class=o>*</span><span class=n>count</span><span class=p>)</span><span class=o>++</span><span class=p>;</span>
	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
		<span class=n>bpf_map_update_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>histogram</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>one</span><span class=p>,</span> <span class=n>BPF_NOEXIST</span><span class=p>);</span>
		<span class=n>bpf_map_update_elem</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binprm_info</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>key</span><span class=p>.</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>exe_path_str</span><span class=p>,</span> <span class=n>BPF_ANY</span><span class=p>);</span>
		<span class=c1>// ...
</span><span class=c1></span>	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>The userspace program will then consume the <code>exe_path</code> for the profiled process to access the <code>.symtab</code> ELF section.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>SEC</span><span class=p>(</span><span class=s>&#34;perf_event&#34;</span><span class=p>)</span>
<span class=kt>int</span> <span class=n>sample_stack_trace</span><span class=p>(</span><span class=k>struct</span> <span class=n>bpf_perf_event_data</span><span class=o>*</span> <span class=n>ctx</span><span class=p>)</span>
<span class=p>{</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=cm>/* Get current task executable pathname */</span>
	<span class=n>task</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=p>)</span><span class=n>bpf_get_current_task</span><span class=p>();</span> <span class=cm>/* Current task struct */</span>
	<span class=n>exe_path</span> <span class=o>=</span> <span class=n>get_task_exe_pathname</span><span class=p>(</span><span class=n>task</span><span class=p>);</span>
	<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>

<span class=cm>/*
</span><span class=cm> * get_task_exe_pathname returns the task exe_file pathname.
</span><span class=cm> * This does not apply to kernel threads as they share the same memory-mapped address space,
</span><span class=cm> * as opposed to user address space.
</span><span class=cm> */</span>
<span class=k>static</span> <span class=n>__always_inline</span> <span class=kt>void</span> <span class=o>*</span><span class=n>get_task_exe_pathname</span><span class=p>(</span><span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>task</span><span class=p>)</span>
<span class=p>{</span>
	<span class=cm>/*
</span><span class=cm>	 * Get ref file path from the task&#39;s user space memory mapping descriptor.
</span><span class=cm>	 * exe_file-&gt;f_path could also be accessed from current task&#39;s binprm struct 
</span><span class=cm>	 * (ctx-&gt;args[2]-&gt;file-&gt;f_path)
</span><span class=cm>	 */</span>
	<span class=k>struct</span> <span class=n>path</span> <span class=n>path</span> <span class=o>=</span> <span class=n>BPF_CORE_READ</span><span class=p>(</span><span class=n>task</span><span class=p>,</span> <span class=n>mm</span><span class=p>,</span> <span class=n>exe_file</span><span class=p>,</span> <span class=n>f_path</span><span class=p>);</span>

	<span class=n>buffer_t</span> <span class=o>*</span><span class=n>string_buf</span> <span class=o>=</span> <span class=n>get_buffer</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
	<span class=k>if</span> <span class=p>(</span><span class=n>string_buf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
	<span class=p>}</span>
	<span class=cm>/* Write path string from path struct to the buffer */</span>
	<span class=n>size_t</span> <span class=n>buf_off</span> <span class=o>=</span> <span class=n>get_pathname_from_path</span><span class=p>(</span><span class=o>&amp;</span><span class=n>path</span><span class=p>,</span> <span class=n>string_buf</span><span class=p>);</span>
	<span class=k>return</span> <span class=o>&amp;</span><span class=n>string_buf</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>[</span><span class=n>buf_off</span><span class=p>];</span>
<span class=p>}</span>
</code></pre></div><p>To retrieve the pathname from the <a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/linux/path.h#L8><code>path</code></a> struct we need to walk the directory hierarchy until reaching the root directory of the same VFS mount. For the sake of simplicity, we don&rsquo;t go into the details of this part.</p><h2 id=the-ebpf-program-trigger>The eBPF program trigger<a hidden class=anchor aria-hidden=true href=#the-ebpf-program-trigger>#</a></h2><p>To run the eBPF program with a fixed frequency the <a href=https://perf.wiki.kernel.org/index.php/Main_Page>Perf</a> subsystem exposes a kernel software event of type CPU clock (<a href=https://elixir.bootlin.com/linux/v6.8.5/source/include/uapi/linux/perf_event.h#L119><code>PERF_COUNT_SW_CPU_CLOCK</code></a>) with user APIs. Luckily, eBPF programs can be attached to those events.</p><p><img loading=lazy src=https://raw.githubusercontent.com/maxgio92/notes/7e1e10ea843e5289390d5b89037dfd7589d1d847/content/images/perf-cpu-clock-sw-event-trigger.svg alt=perf-event-software-cpu-clock-trigger-bpf></p><p>So, after the program is loaded:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=p>(</span>
	<span class=nx>bpf</span> <span class=s>&#34;github.com/aquasecurity/libbpfgo&#34;</span>
	<span class=s>&#34;github.com/pkg/errors&#34;</span>
	<span class=s>&#34;golang.org/x/sys/unix&#34;</span><span class=nx>implements</span> <span class=nx>access</span> <span class=nx>to</span> <span class=nx>ELF</span> <span class=nx>object</span> <span class=nx>files</span><span class=p>.</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>loadAndAttach</span><span class=p>(</span><span class=nx>probe</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=nx>bpfModule</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>bpf</span><span class=p>.</span><span class=nf>NewModuleFromBuffer</span><span class=p>(</span><span class=nx>probe</span><span class=p>,</span> <span class=s>&#34;sample_stack_trace&#34;</span><span class=p>)</span>
	<span class=c1>// ...
</span><span class=c1></span>	<span class=k>defer</span> <span class=nx>bpfModule</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>

	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>bpfModule</span><span class=p>.</span><span class=nf>BPFLoadObject</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// ...
</span><span class=c1></span>	<span class=p>}</span>

	<span class=nx>prog</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>bpfModule</span><span class=p>.</span><span class=nf>GetProgram</span><span class=p>(</span><span class=s>&#34;sample_stack_trace&#34;</span><span class=p>)</span>
	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
		<span class=c1>// ...
</span><span class=c1></span>	<span class=p>}</span>

	<span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>this Perf event can be leveraged to run the sampler by interrupting the CPUs every x milliseconds independently of the process running.
Because Perf exposes user APIs, the userspace program can prepare the clock software events and attach the loaded <a href=https://ebpf-docs.dylanreimerink.nl/linux/program-type/BPF_PROG_TYPE_PERF_EVENT/>BPF_PROG_TYPE_PERF_EVENT</a> eBPF program to them:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kn>import</span> <span class=p>(</span>
	<span class=nx>bpf</span> <span class=s>&#34;github.com/aquasecurity/libbpfgo&#34;</span>
	<span class=s>&#34;github.com/pkg/errors&#34;</span>
	<span class=s>&#34;golang.org/x/sys/unix&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>loadAndAttach</span><span class=p>(</span><span class=nx>probe</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
	<span class=c1>// Load the program...
</span><span class=c1></span>
	<span class=nx>cpus</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>NumCPU</span><span class=p>()</span>

	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>cpus</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
		<span class=nx>attr</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>unix</span><span class=p>.</span><span class=nx>PerfEventAttr</span><span class=p>{</span>
			<span class=nx>Type</span><span class=p>:</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>PERF_TYPE_SOFTWARE</span><span class=p>,</span>		<span class=c1>// If type is PERF_TYPE_SOFTWARE, we are measuring software events provided by the kernel.
</span><span class=c1></span>			<span class=nx>Config</span><span class=p>:</span> <span class=nx>unix</span><span class=p>.</span><span class=nx>PERF_COUNT_SW_CPU_CLOCK</span><span class=p>,</span>	<span class=c1>// This reports the CPU clock, a high-resolution per-CPU timer.
</span><span class=c1></span>			
			<span class=c1>// A &#34;sampling&#34; event is one that generates an overflow notification every N events,
</span><span class=c1></span>			<span class=c1>// where N is given by sample_period.
</span><span class=c1></span>			<span class=c1>// sample_freq can be used if you wish to use frequency rather than period.
</span><span class=c1></span>			<span class=c1>// sample_period and sample_freq are mutually exclusive.
</span><span class=c1></span>			<span class=c1>// The kernel will adjust the sampling period to try and achieve the desired rate.
</span><span class=c1></span>			<span class=nx>Sample</span><span class=p>:</span> <span class=mi>10</span> <span class=o>*</span> <span class=mi>1000</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>,</span>
		<span class=p>}</span>
		
		<span class=c1>// Create the perf event file descriptor that corresponds to one event that is measured.
</span><span class=c1></span>		<span class=c1>// We&#39;re measuring a clock timer software event just to run the program on a periodic schedule.
</span><span class=c1></span>		<span class=c1>// When a specified number of clock samples occur, the kernel will trigger the program.
</span><span class=c1></span>		<span class=nx>evt</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>unix</span><span class=p>.</span><span class=nf>PerfEventOpen</span><span class=p>(</span>
			<span class=nx>attr</span><span class=p>,</span>	<span class=c1>// The attribute set.
</span><span class=c1></span>			<span class=o>-</span><span class=mi>1</span><span class=p>,</span>	<span class=c1>// All the tasks.
</span><span class=c1></span>			<span class=nx>i</span><span class=p>,</span>	<span class=c1>// on the Nth CPU.
</span><span class=c1></span>			<span class=o>-</span><span class=mi>1</span><span class=p>,</span>	<span class=c1>// The group_fd argument allows event groups to be created.
</span><span class=c1></span>			<span class=mi>0</span><span class=p>,</span>	<span class=c1>// The flags.
</span><span class=c1></span>		<span class=p>)</span>
		<span class=c1>// ...
</span><span class=c1></span>		<span class=nx>https</span><span class=p>:</span><span class=c1>//blog.px.dev/static/7b13192052f268bfd22577215d0c9f01/sample-stack-trace-function.png
</span><span class=c1></span>		<span class=c1>// Attach the BPF program to the sampling perf event.
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>prog</span><span class=p>.</span><span class=nf>AttachPerfEvent</span><span class=p>(</span><span class=nx>evt</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=k>return</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrap</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;error attaching the BPF probe to the sampling perf event&#34;</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}</span>

	<span class=k>return</span> <span class=kc>nil</span>
<span class=p>}</span>
</code></pre></div><blockquote><p>In this example we&rsquo;re using the <a href=https://github.com/aquasecurity/libbpfgo>libbpfgo</a> library.</p></blockquote><h2 id=wrapping-up>Wrapping up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>The user program loads the eBPF program, attaches it to the Perf event in order to be triggered periodically, and samples stack traces. Trace instruction pointers are resolved into symbols and before returning, the statistics about residency fraction are calculated with data stored in the histogram.</p><p>The statistics are finally printed out like below:</p><pre><code>80% main();foo();bar()
20% main();foo();baz()
</code></pre><p>You can see a full working example at <a href=https://github.com/maxgio92/yap>github.com/maxgio92/yap</a>. YAP is a sampling-based, low overhead kernel-assisted profiler I started for learning eBPF and how a program is executed by the CPU.</p><h2 id=next>Next<a hidden class=anchor aria-hidden=true href=#next>#</a></h2><p>I personally would like to use statistics to build graph structures, like <a href=https://github.com/brendangregg/FlameGraph>flamegraphs</a>.</p><p>Also, I&rsquo;d like to investigate other ways to extend symbolization support for stripped binaries and collect traces when binaries are built without frame pointers.</p><h2 id=thanks>Thanks<a hidden class=anchor aria-hidden=true href=#thanks>#</a></h2><p>Thanks for your time, I hope you enjoyed this blog.</p><p>I want to special thank <a href=https://github.com/pixie-io/>Pixie</a> for their knowledge sharing on their <a href=https://blog.px.dev/>blog</a>, and the Linux project for BPF code <a href=https://github.com/torvalds/linux/blob/v6.8/samples/bpf>samples</a>.</p><p>Any form of feedback is more than welcome. Hear from you soon!</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://blog.px.dev/cpu-profiling/>https://blog.px.dev/cpu-profiling/</a></li><li><a href=https://github.com/torvalds/linux/blob/v6.8/samples/bpf/trace_event_kern.c>https://github.com/torvalds/linux/blob/v6.8/samples/bpf/trace_event_kern.c</a></li><li><a href=https://refspecs.linuxbase.org/elf/>https://refspecs.linuxbase.org/elf/</a></li><li><a href=https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY>https://groups.google.com/g/golang-nuts/c/wtw0Swe0CAY</a></li><li><a href=https://0xax.gitbooks.io/linux-insides/content/index.html>https://0xax.gitbooks.io/linux-insides/content/index.html</a></li><li><a href=https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them>https://www.polarsignals.com/blog/posts/2022/01/13/fantastic-symbols-and-where-to-find-them</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.maxgio.me/tags/profiling/>profiling</a></li><li><a href=https://blog.maxgio.me/tags/optimization/>optimization</a></li><li><a href=https://blog.maxgio.me/tags/ebpf/>ebpf</a></li></ul><nav class=paginav><a class=next href=https://blog.maxgio.me/posts/unleashing-power-frame-pointers-execution-environment/><span class=title>Next »</span><br><span>Unleashing the power of frame pointers pt.1 - The execution environment</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler on twitter" href="https://twitter.com/intent/tweet/?text=Unleashing%20the%20power%20of%20frame%20pointers%20for%20profiling%20pt.2%20-%20Writing%20a%20simple%20profiler&url=https%3a%2f%2fblog.maxgio.me%2fposts%2funleashing-power-frame-pointers-writing-simple-continuous-profiler%2f&hashtags=profiling%2coptimization%2cebpf"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unleashing the power of frame pointers for profiling pt.2 - Writing a simple profiler on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.maxgio.me%2fposts%2funleashing-power-frame-pointers-writing-simple-continuous-profiler%2f&title=Unleashing%20the%20power%20of%20frame%20pointers%20for%20profiling%20pt.2%20-%20Writing%20a%20simple%20profiler&summary=Unleashing%20the%20power%20of%20frame%20pointers%20for%20profiling%20pt.2%20-%20Writing%20a%20simple%20profiler&source=https%3a%2f%2fblog.maxgio.me%2fposts%2funleashing-power-frame-pointers-writing-simple-continuous-profiler%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.maxgio.me/>Maxgio's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script><script>document.querySelectorAll('pre > code').forEach((codeblock)=>{const container=codeblock.parentNode.parentNode;const copybutton=document.createElement('button');copybutton.classList.add('copy-code');copybutton.innerHTML='copy';function copyingDone(){copybutton.innerHTML='copied!';setTimeout(()=>{copybutton.innerHTML='copy';},2000);}
copybutton.addEventListener('click',(cb)=>{if('clipboard'in navigator){navigator.clipboard.writeText(codeblock.textContent);copyingDone();return;}
const range=document.createRange();range.selectNodeContents(codeblock);const selection=window.getSelection();selection.removeAllRanges();selection.addRange(range);try{document.execCommand('copy');copyingDone();}catch(e){};selection.removeRange(range);});if(container.classList.contains("highlight")){container.appendChild(copybutton);}else if(container.parentNode.firstChild==container){}else if(codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"){codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);}else{codeblock.parentNode.appendChild(copybutton);}});</script></body></html>